#!/bin/bash
#
# Copyright (c) 2001 SuSE GmbH Nuernberg, Germany.  All rights reserved.
# Author: Christian Zoz <zoz@suse.de>
#
# TODO:
# -> Perhaps respect START_NAMED?

RESOLVCONF=/etc/resolv.conf
PROGNAME=`basename $0`
RETVAL=0

usage () {
  cat << EOT
  usage:   $PROGNAME <action> <options>
  action:  modify, restore, cleanup or check
  options:                               mandatory for:
    -s|--service <service>               modify, restore
    -e|--extension <string>
    -p|--process <process>               modify
    -i|--pid <pid>
    -f|--script <pathname of script>     modify
    -t|--text <text>                     modify
    -l|--searchlist <list of domains>
    -d|--domain <domain>
    -n|--nameservers <addresses>
    -o|--save_now <pathname of file>
    -a|--save_later <pathname of file>
    -k|--keep
    -q|--quiet 
    -v|--verbose 
    -h|--help                            (does not need an action)
  cleanup and check ignore all options except -q and -v
EOT
  if [ -n "$1" ] ; then
     echo
     ERROR="  ERROR:   "
     echo -e "$*\n" | while read line; do
       echo "${ERROR}${line}" >&2
       ERROR="           "
     done
  fi
  exit 1
}

debug () {
  test "$VERBOSE" = "yes" || return
  echo -e "debug: $*" >&2
}

warn () {
  test "$QUIET" = "yes" && return
  echo -e "$*" >&2
}

log () {
  logger -t "$PROGNAME" "$*"
  debug "$*"
  if [ "$ACTION" = "cleanup" ] ; then
    echo -e "$*"
#    XX="modify_resolfconf:"
#    echo -e "$*" | fmt -60 |
#    while read line; do
#      echo "$XX $line"
#      XX="                  "
#    done
  fi
}

write_resolvconf () {
  cat << EOT > $RESOLVCONF
### BEGIN INFO
#
# Modified_by:  $SERVICE
# Backup:       $BACKUP
# Process:      $PROC
# Process_id:   $PID
# Script:       $SCRIPT
# Saveto:       $SAVELATER
# Info:        
EOT
echo -e "$TEXT" |
  fmt -60 |
  while read line ; do 
    echo "#               $line"; 
  done |
   sed "/^[#[:space:]]*$/d" >> $RESOLVCONF
  cat << EOT >> $RESOLVCONF
#
### END INFO

EOT
echo "$RC_REST" >> $RESOLVCONF
#domain $DOMAIN
#search $SEARCH
#EOT
#for a in $DNS; do
#  echo "nameserver $a" >> $RESOLVCONF
#done
chmod 644 $RESOLVCONF
}

###########################################################
# Parse commandline
###########################################################

# Note that we use `"$@"' to let each command-line parameter expand to a 
# separate word. The quotes around `$@' are essential!
# We need TEMP as the `eval set --' would nuke the return value of getopt.
TEMP=`getopt -o s:e:p:i:f:t:l:d:n:qvho:a:k --long \
service:,extension:,process:,pid:,script:,text:,searchlist:,domain:,\
nameservers:,quiet,verbose,help,save_now:,save_later:,keep \
-n "  $PROGNAME" -- "$@"`
test $? != 0 && usage

# Now set the parsed args but save the original commandline for recursive calls
COMMANDLINE="$@"
# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"
# echo "$TEMP"

while true ; do
  case "$1" in
    -s|--service) SERVICE="$2"; shift 2;;
    -e|--extension) EXT="$2"; shift 2;;
    -p|--process) PROC="$2"; shift 2;;
    -i|--pid) PID="$2"; shift 2;;
    -f|--script) SCRIPT="$2"; shift 2;;
    -t|--text) TEXT="$2"; shift 2;;
    -l|--searchlist) SEARCH="$2"; shift 2;;
    -d|--domain) DOMAIN="$2"; shift 2;;
    -n|--nameservers) DNS="$2"; shift 2;;
    -q|--quiet) QUIET=yes; shift;;
    -v|--verbose) VERBOSE=yes; shift;;
    -h|--help) usage;;
    -o|--save_now) SAVENOW="$2"; shift 2;;
    -a|--save_later) SAVELATER="$2"; shift 2;;
    -k|--keep) KEEP=yes; shift;;
    --) shift ; break ;;
    *) echo "Internal error! : $1" ; exit 1 ;;
  esac
done
test $# -ne 1 && usage "Exactly one action may be given.\n"\
                       "Currently given actions: $*"
ACTION=$1

###########################################################
# Check if the arguments to the options are usefull
###########################################################

case $ACTION in
  modify)
#z#    case "$SERVICE" in
#z#      dhclient|dhcpcd|pppd|ipppd|pcmcia|hotplug) ;;
#z#      *) usage "service must be one of dhclient dhcpcd" \
#z#               " pppd ipppd pcmcia hotplug";;
#z#    esac
    test -z "$SERVICE" && usage "a vaild service must be set with --service"

    if [ "$SERVICE" != "hotplug" ] ; then
      if [ -z "$PROC" ] ; then
        usage "a running process/daemon must be set with --process"
      else
        PROCPID=`pidofproc $PROC 2>/dev/null`
        if [ -z "$PROCPID" ] ; then
          usage "$PROC is not running currently, this may not happen"
        else
          debug "pid of prodess $PROC is $PROCPID"
        fi
      fi
    fi
    
    if [ -z "$PID" ] ; then
      PID="$PROCPID"
      # usage "you must set the pid of $PROC with --pid"
    else
      PIDPROC=`ps h $PID 2>/dev/null |(read a b c d e f; echo $e)`
      if [ -z "$PIDPROC" ] ; then
        warn "there is no process with id $PID"
      else
        debug "process with pid $PID is $PIDPROC"
      fi
    fi
    
    if [ -z "$SCRIPT" ] ; then
      usage "you must set the script that modifies $RESOLVCONF with --script"
    else
      if [ -e "$SCRIPT" ] ; then
        debug "script $SCRIPT found"
      else
        usage "there is no script named $SCRIPT"
      fi
    fi
    
    if [ -z "$TEXT" ] ; then
      usage "You have to provide an descriptive text with --text\n" \
            "With --text=- you can use a here document"
    else
      # If TEXT="-" read it as here document
      if [ "$TEXT" = "-" ] ; then
        TEXT=""
        while read a; do
          test -z "$a" && a="\n\n"
          TEXT="$TEXT $a"
        done
      fi
    fi

    if [ -n "$DOMAIN" -a -n "$SEARCH" ] ; then
      usage "only one of --domain and --searchlist may be used\n" \
            "in resolv.conf search and domain are mutually exclusiv"
    fi
    ;;
  restore) 
#z#    case "$SERVICE" in
#z#      dhclient|dhcpcd|pppd|ipppd|pcmcia|hotplug) ;;
#z#      *) usage "service must be one of dhclient dhcpcd" \
#z#               " pppd ipppd pcmcia hotplug";;
#z#    esac
    test -z "$SERVICE" && usage "a vaild service must be set with --service"
    ;;
  cleanup|check)
    # ignore all options
#z#    SERVICE="$ACTION"
    KEEP=""
    SAVENOW=""
    ;;
  *) usage "$ACTION is not a valid action" ;;
esac

BACKUP="${RESOLVCONF}.saved.by.$SERVICE"
test -n "$EXT" && BACKUP="${BACKUP}.${EXT}"

###########################################################
# respect MODIFY_RESOLV_CONF_DYNAMICALLY in rc.config
###########################################################

MODIFY=`sed -n "/^[[:space:]]*MODIFY_RESOLV_CONF_DYNAMICALLY=/s/^.*=\|\"//gp" \
                                                                 /etc/rc.config`
if [ -n "$MODIFY" -a "$MODIFY" != "yes" -a "$ACTION" != "check" ] ; then
  if [ "$ACTION" = "cleanup" ] ; then
    ls $BACKUP* &>dev/null &&
      log "Not cleaning up $RESOLVCONF backups due to " \
          "MODIFY_RESOLV_CONF_DYNAMICALLY=no"
  else
    log "Service $SERVICE tried to modify $RESOLVCONF, but it"
    log "was not modified due to MODIFY_RESOLV_CONF_DYNAMICALLY=no"
  fi
  exit
fi

###########################################################
# Read current resolv.conf
###########################################################

if [ -e $RESOLVCONF ] ; then
  RC_BLOCK=`sed -n "/### BEGIN INFO/,/### END INFO/s/^[[:space:]#]*//p" \
                                                               $RESOLVCONF`
  if [ -n "$RC_BLOCK" ] ; then
    while read NAME TOKEN; do
      # Note the quotes around RC_BLOCK. Without it we get all in one line.
      eval $NAME=`echo "$RC_BLOCK" | sed -n "/^$TOKEN:[[:space:]]*/s///p"`
      debug "$NAME=${!NAME}"
    done << "      EOL"
      RC_SERVICE   Modified_by
      RC_BACKUP    Backup
      RC_PROC      Process
      RC_PID       Prodess_id
      RC_SCRIPT    Script
      RC_SAVELATER Saveto
      EOL
    # Here we want all in one line so we do not quote RC_BLOCK, but we lose
    # all formatting of the text (to be enhanced). 
    RC_TEXT=`echo $RC_BLOCK | sed -e "s/^.*Info:[[:space:]]*//" \
                                  -e "s/ END INFO.*$//"`
    debug "RC_TEXT=`echo $RC_TEXT | cut -c1-20` ..."
  fi
#  RC_SEARCH=`sed -n "/^search[[:space:]]*/s///p" $RESOLVCONF`
#  RC_DOMAIN=`sed -n "/^domain[[:space:]]*/s///p" $RESOLVCONF`
#  RC_DNS=`sed -n "/^nameserver[[:space:]]*/s///p" $RESOLVCONF`
  RC_REST=`sed "/### BEGIN INFO/,/### END INFO/d" $RESOLVCONF`

fi

###########################################################
# Divide all available backups
###########################################################
# Check all existing backups and divide them into valid direct, valid indirect
# and invalid backups.
# "all existing backups" = all files /etc/resolv.conf.saved.by.* and all
#                          files found in the backup field of another
#                          valid backup
# "valid direct" = file which the backup entry in resolv.conf points to
# "valid indirect" = file which the backup entry of another valid backup
#                    points to
# "invalid" = files /etc/resolv.conf.saved.by.* which are not valid
# All valid backups build a stack of files. These files are stored in three
# variables:
# DIRECT_BACKUP: Contains the only valid direct backup.
# INDIRECT_BACKUPS: Contains all indirect backups except the last of the stack.
#                  Files are ordered like the stack. The first is the backup
#                  of the valid direct backup.
# LAST_BACKUP: Contains the last file of the stack of valid indirect backups.
#              This file does not contain an info block or has an invalid
#              entry in its backup field.
# INVALID_BACKUPS: Contains all invalid backups sorted in chronological
# order, the newest first. This files are only used if there is no valid
# backup, but resolv.conf was modified dynamically.

read_field_backup () { 
ls "$*" &>/dev/null || return
BAFI=`\
sed -n "/### BEGIN INFO/,/### END INFO/s/^[[:space:]#]*Backup:[[:space:]]*//p" \
"$*"`
ls "$BAFI" 2>/dev/null
}

# get all backups in chronoligical order, the newest first
ALL_BACKUPS=`ls -t ${RESOLVCONF}.saved.by* \
                     $(read_field_backup ${RESOLVCONF}*) \
               2>/dev/null | uniq`
test -r "$RC_BACKUP" && DIRECT_BACKUP="$RC_BACKUP"
debug "(0) DIRECT_BACKUP: $DIRECT_BACKUP"
debug "(0) ALL_BACKUPS: $ALL_BACKUPS"

if [ -n "$ALL_BACKUPS" ] ; then
  # At first put all except DIRECT_BACKUP from ALL_BACKUPS to INVALID_BACKUPS
  INVALID_BACKUPS=`\
  for a in $ALL_BACKUPS; do
    test "$a" != "$DIRECT_BACKUP" && echo "$a"
  done`
  # Then we are going to build a chain of backups and delete the chain elements
  # from INVALID_BACKUPS.
  NEXT_BACKUP=`read_field_backup "$DIRECT_BACKUP"`
  while [ -r "$NEXT_BACKUP" ] ; do
    debug "(searching stack) NEXT_BACKUP=$NEXT_BACKUP"
    # At first delete NEXT_BACKUP from INVALID_BACKUPS
    INVALID_BACKUPS=`\
    for a in $INVALID_BACKUPS; do
      test "$a" != "$NEXT_BACKUP" && echo "$a"
    done`
    # INDIRECT_BACKUPS contains all elements except the last ...
    INDIRECT_BACKUPS="$INDIRECT_BACKUPS $LAST_BACKUP"
    # ... which is always in LAST_BACKUP
    LAST_BACKUP="$NEXT_BACKUP"
    NEXT_BACKUP=`read_field_backup "$NEXT_BACKUP"`
    # Detect a loop
    for a in $DIRECT_BACKUP $INDIRECT_BACKUPS $LAST_BACKUP; do
      test "$NEXT_BACKUP" = "$a" && NEXT_BACKUP=""
    done
  done
  debug "(1) DIRECT_BACKUP: $DIRECT_BACKUP"
  debug "(1) INDIRECT_BACKUPS: $INDIRECT_BACKUPS"
  debug "(1) LAST_BACKUP: $LAST_BACKUP"
  debug "(1) INVALID_BACKUPS: $INVALID_BACKUPS"
fi

# The remaining invalid backups have to be reordered. First all backups 
# without an infoblock then those with info block, both groups
# still chronologically ordered.
unset IB_1 IB_2 IB_3
for a in $INVALID_BACKUPS; do
  b=`sed -n "/### BEGIN INFO/,/### END INFO/p" $a`
  if [ -z "$b" ] ; then
    IB_1="$IB_1 $a"
  else
    IB_2="$IB_2 $a"
  fi
done
INVALID_BACKUPS="$IB_1 $IB_2"
debug "(2) INVALID_BACKUPS: $INVALID_BACKUPS"
# Then we select all backups with the correct service in the filename. We now
# have two groups, both ordered as before.
# Then we split the first group in those which additionally contain the
# given extension in the filename still sustainig the old order.
unset IB_1 IB_2 IB_3
for a in $INVALID_BACKUPS; do
  if echo $a | grep "$SERVICE" &>/dev/null; then
    if echo $a | grep "$SERVICE.$EXT" &>/dev/null; then
      IB_1="$IB_1 $a"
    else
      IB_2="$IB_2 $a"
    fi
  else
    IB_3="$IB_3 $a"
  fi
done
INVALID_BACKUPS="$IB_1 $IB_2 $IB_3"
debug "(3) INVALID_BACKUPS: $INVALID_BACKUPS"
# Now the list starts with backups that fit most regarding the  name of the
# backup and then at first these which seem to be backups of unmodified files.
# Now we choose the first one. If it has an info block we try to find an
# according stack as before and then take the last element of it.
CHOOSEN_BACKUP=`echo "$INVALID_BACKUPS" | (read a b; echo "$a")`
SUCC_BACKUP=`read_field_backup "$CHOOSEN_BACKUP"`
unset LOOP_STOP
while [ -r "$SUCC_BACKUP" ] ; do
  LOOP_STOP="$LOOP_STOP $SUCC_BACKUP"
  CHOOSEN_BACKUP="$SUCC_BACKUP"
  SUCC_BACKUP=`read_field_backup "$CHOOSEN_BACKUP"`
  # detect a loop
  for a in $LOOP_STOP; do
    test "$a" = "$SUCC_BACKUP" && SUCC_BACKUP=""
  done
done
# IMHO this should be the at least dynamically modified file of all invalid
# backups. 
INVALID_BACKUPS="$CHOOSEN_BACKUP $INVALID_BACKUPS"
# We delete all other invalid ones immediately.
#for a in $INVALID_BACKUPS; do
#  MSG="removing invalid backups: "
#  if [ "$a" != "$CHOOSEN_BACKUP" ] ; then
#    rm $a
#    log "$MSG$a"
#    MSG="                          "
#  fi
#done
debug "(4) INVALID_BACKUPS: $INVALID_BACKUPS"

###########################################################
# Finally execute the requested action
###########################################################

# If there is a resolv.conf and --save_now was set then lets do it:
test -n "$SAVENOW" -a -e "$RESOLVCONF" && cp -p --backup=t $RESOLVCONF $SAVENOW

debug "BACKUP=$BACKUP"
case $ACTION in
  modify)
    # maybe there is no resolv.conf or current resolv.conf points to
    # the same backup file that should be used now
    # We don't copy resolv.conf if there is an valid backup of the same 
    # service with the same private extension or ...
    for a in $DIRECT_BACKUP $INDIRECT_BACKUPS $LAST_BACKUP; do
      test "$BACKUP" = "$a" && SAVE="no"
    done
    # ... there isn't any
    if [ -e $RESOLVCONF -a "$SAVE" != "no" ] ; then
       cp -p $RESOLVCONF $BACKUP
       debug "$RESOLVCONF saved to $BACKUP"
    fi
    # Only one of $DOMAIN and $SEARCH does contain something
    if [ -n "$DOMAIN" ] ; then
      RC_REST=`echo "$RC_REST" |
                 sed -e "/^[[:space:]]*\(domain\|search\)[[:space:]]/d"`
      RC_REST=`echo -e "$RC_REST\ndomain $DOMAIN"`
    fi
    if [ -n "$SEARCH" ] ; then
      RC_REST=`echo "$RC_REST" |
                 sed -e "/^[[:space:]]*\(domain\|search\)[[:space:]]/d"`
      RC_REST=`echo -e "$RC_REST\nsearch $SEARCH"`
    fi
    if [ -n "$DNS" ] ; then
      RC_REST=`echo "$RC_REST" | sed "/^[[:space:]]*nameserver[[:space:]]/d"`
      for a in $DNS; do
        RC_REST=`echo -e "$RC_REST\nnameserver $a"`
      done
    fi
    write_resolvconf
    log "Service $SERVICE modified $RESOLVCONF. See info block in this file"
   ;;
  restore)
    # If __save_later was set when modifying then we save the temporary
    # resolv.conf
    test -n "$RC_SAVELATER" -a -e "$RESOLVCONF" &&
      cp -p --backup=t $RESOLVCONF $RC_SAVELATER
    # We only restore if a backup with the correct name (already in $BACKUP) 
    # exists. If this backup is valid we have to save the integrity of a 
    # possibly existing backup stack. If this backup is invalid (= not part
    # of a stack) then we just restore it, even if we invalidate an existing
    # stack.
    if [ -e "$BACKUP" ] ; then
      # Now we search the possibly existing stack and store the two 
      # predecessors and one successor of it. 
      # Don't remove the empty entry ("") from the list.
      for a in $RESOLVCONF $DIRECT_BACKUP $INDIRECT_BACKUPS \
               $LAST_BACKUP ""; do
        P="$C"
        C="$S"
        S="$a"
        test "$C" = "$BACKUP" && break
      done
      # If we did not found the Backup in the stack of valid backups, we
      # write BACKUP to C and set RESOLVCONF as its predecessor (P). Because
      # the Backup can have a successor even if it is called invalid, we have
      # to look for it.
      if [ "$C" != "$BACKUP" ] ; then
        P="$RESOLVCONF"
        C="$BACKUP"
        S=`read_field_backup "$BACKUP"`
      fi
      debug "(restore) P=$P C=$C S=$S"
      # If we were called with --keep, we don't restore the backup but
      # keep the temporary settings. 
      if [ "$KEEP" = "yes" ] ; then
        # We have to keep the resolver settings, but not the meta information
        # in the info block. There are two cases:
	# 1) The Backup (C) was the last in the stack (S="") then we remove the
	#    info block from its predecessor (P) and remove C.
        # 2) The Backup has itself a backup (S!="") then we have to replace the
        #    info block in the predecessor (P) with that from the Backup (C),
        #    but keep everything else from P. And remove C. 
        TMPFILE=`mktemp /tmp/mdfrc.XXXXXX`
        cp -p $P $TMPFILE 
        if [ "$S" = "" ] ; then
          sed "/### BEGIN INFO/,/### END INFO/d" $TMPFILE > $P
          log "kept $P and removed info block"
        else
          sed -n "/### BEGIN INFO/,/### END INFO/p" $C > $P
          sed "/### BEGIN INFO/,/### END INFO/d" $TMPFILE >> $P
          log "kept $P and changed info block"
        fi
        rm $C
        log "removed $C"
        rm $TMPFILE
      else 
        # Don't keep the temporary settings, restore.
        # All we have to do is to move the Backup (C) to its predecessor (P),
        # because the backup field of the previous predecessor already points
        # to the filename of P and the backup field of C what then will be in
        # P points to S (if existing).
        mv $C $P
        log "restored $C to $P"
      fi
    else
      # If no extension was given we search for backup files of the calling
      # service with private extensions and call us recursivle for every
      # found extension.
      if [ "$EXT" = "" ] ; then
        for a in `ls -t "$BACKUP"* 2>/dev/null`; do
          EXT=${a##$BACKUP.}
          $0 $COMMANDLINE -e "$EXT"
        done
        if [ "$EXT" != "" ] ; then
          exit
        fi
      fi
      log "no matching backup found, left everything alone"
    fi
    # If there is no backup left, make sure that $RESOLVCONF does not contain
    # an info block
    if [ -z "`ls ${RESOLVCONF}.saved.by.* $LAST_BACKUP $INDIRECT_BACKUPS \
                 $DIRECT_BACKUP $INVALID_BACKUPS 2>/dev/null`" ] ; then
      if grep -qs "### BEGIN INFO" $RESOLVCONF 2>/dev/null; then
        log "removing info block from $RESOLVCONF, because there is" \
            "no backup left"
        TMPFILE=`mktemp /tmp/mdfrc.XXXXXX`
        cp -p $RESOLVCONF $TMPFILE
        sed "/### BEGIN INFO/,/### END INFO/d" $TMPFILE >  $RESOLVCONF
        rm $TMPFILE
        chmod 644 $RESOLVCONF
      fi
    fi
    ;;
  cleanup)
    # If $RESOLVCONF was modified (= RC_BLOCK nonempty) we have to restore it
    if [ -n "$RC_BLOCK" ] ; then
      # If --save_later was set when modifying then we save the temporary
      # resolv.conf
      test -n "$RC_SAVELATER" -a -e "$RESOLVCONF" &&
        cp -p --backup=t $RESOLVCONF $RC_SAVELATER
      # Search the most reasonable backup. That is (if existing) the LAST_BACKUP
      # then the DIRECT_BACKUP and last the first one of INVALID_BACKUPS
      BACKUP=`echo "$LAST_BACKUP $DIRECT_BACKUP $INVALID_BACKUPS" \
              | (read a b; echo $a)`
      if [ -e "$BACKUP" ] ; then
        mv $BACKUP $RESOLVCONF
        log "restored $RESOLVCONF from $BACKUP"
      fi
    fi
    # Now we remove all backups
    MSG=`rm -v $LAST_BACKUP $INDIRECT_BACKUPS $DIRECT_BACKUP \
               $INVALID_BACKUPS 2>/dev/null`
    test -n "$MSG" && log "Deleted the following stale backups: $MSG"
    # After cleaning up resolc.conf should not contain an INFO block that
    # marks it as modified. If it somehow happens that it has it, we remove it.
    if grep -qs "### BEGIN INFO" $RESOLVCONF 2>/dev/null; then
      TMPFILE=`mktemp /tmp/mdfrc.XXXXXX`
      cp -p $RESOLVCONF $TMPFILE
      sed "/### BEGIN INFO/,/### END INFO/d" $TMPFILE >  $RESOLVCONF
      rm $TMPFILE
      chmod 644 $RESOLVCONF
    fi
    ;;
  check)
    if [ -z "$RC_BLOCK" ] ; then
      warn "$RESOLVCONF not modified"
    else
      warn $RC_TEXT
      RETVAL=1
    fi
    ;;
esac

# nscd -i hosts
debug "finished"
exit $RETVAL
