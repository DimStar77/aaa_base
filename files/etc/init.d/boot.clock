#!/bin/bash
#
# Copyright (c) 2001-2002 SuSE Linux AG, Nuernberg, Germany.
# Copyright (c) 2008,2009 SuSE LINUX Products GmbH, Nuernberg, Germany.
# All rights reserved.
#
# /etc/init.d/boot.clock
#
### BEGIN INIT INFO
# Provides:          boot.clock
# Required-Start:    boot.rootfsck
# Required-Stop:     boot.rootfsck
# X-Start-Before:    boot.localfs
# X-Stop-After:      $null
# Default-Start:     B S
# Default-Stop:
# Description:       Read hardware clock and set system clock
# Short-Description: Read hardware clock and set system clock
### END INIT INFO

. /etc/rc.status
. /etc/sysconfig/clock

#
# Don't run into trouble due daylight-saving time
#
USE_ADJFILE=no
case "$HWCLOCK" in
*-u*) USE_ADJFILE=yes
esac
test "$SYSTOHC" != yes && USE_ADJFILE=no

#
# Don't use hwclock if not valid
#
USE_HWCLOCK=yes
case "$(uname -i)" in
s390*) USE_HWCLOCK=no
esac
test -e /proc/sys/xen/independent_wallclock && USE_HWCLOCK=no

#
# Get current status of kernel time variables, if kernel
# is within "11 minute mode" do not adjust HW clock nor
# write system time back to HW clock, bug bnc#492921.
#
ELEVENMIN_MODE=no
typeset -i STA_CLOCK=$(adjtimex --print | sed -rn '/^[[:blank:]]*status:/{ s/[^[:digit:]]*([[:digit:]]+)/\1/p; }')
test $((STA_CLOCK & 65)) -eq 1 && ELEVENMIN_MODE=yes

#
# Without having rtc_cmos module loaded hwclock will fail on at least x86
#
rtc_rule()
{
    local temprules=/dev/.udev/rules.d
    local uevseqnum=/sys/kernel/uevent_seqnum
    local rule=$temprules/95-rtc-cmos.rules
    local -i start=0 end=0

    if test -e /dev/rtc ; then
	${1+"$@"}
	return $?
    fi

    if test -z "$(/sbin/modprobe -l rtc_cmos)" ; then
	${1+"$@"}
	return $?
    fi

    /bin/mkdir -m 0755 -p $temprules
    echo ACTION==\"add\", KERNEL==\"rtc0\", RUN=\"${1+"$@"} --rtc=\$env{DEVNAME}\" > $rule

    test -e $uevseqnum && read -t 1 start < $uevseqnum

    if /sbin/modprobe -q rtc_cmos ; then
	test -e $uevseqnum && read -t 1 end < $uevseqnum
	if test $start -lt $end ; then
	    /sbin/udevadm settle --quiet --seq-start=$start --seq-end=$end
	else
	    /sbin/udevadm settle --quiet
	fi
    else
	rm -f $rule
	${1+"$@"}
    fi
}

rc_reset

case "$1" in
    start|restart|reload|force-reload)
	#
	# mkinitrd will set this variable if the system time was older than
	# the mkinitrd.rpm build time.
	if test -n "$SYSTEM_TIME_INCORRECT" ; then
	    echo -n "The system time was incorrect: '${warn}$SYSTEM_TIME_INCORRECT${norm}'"
	    rc_status -s
	    rc_exit
	fi
	if test "$USE_HWCLOCK" != yes ; then

	    echo -n Setting up the System Clock

	    # On s390 the hwclock is set outside Linux currently.  The kernel
	    # always assumes it to be set to UTC.  So if it is set to local
	    # time, we have to compensate for that.  We might achieve this
	    # using this special settimeofday(2) linux feature:
	    #   Under  Linux there is some peculiar `warp clock' semantics
	    #   associated to the settimeofday system call if on the  very
	    #   first  call  (after  booting) that has a non-NULL tz argu-
	    #   ment, the tv argument is NULL and the tz_minuteswest field
	    #   is  nonzero.  In  such  a case it is assumed that the CMOS
	    #   clock is on local time, and that it has to be  incremented
	    #   by  this  amount to get UTC system time.  No doubt it is a
	    #   bad idea to use this feature.  (settimeofday(2) man page)
	    # But unless someone complains we simply will use date(1) to shift
	    # the system time by the difference between UTC and local time, if
	    # the system clock is set to local time.  This will introduce a
	    # minimal shift due to the delay between gettimeofday and
	    # settimeofday, and it only works as long as $0 is executed
	    # exactly once, at boot.

	    unset TZ

	    case "$HWCLOCK" in
	    *-l*)
		date --set "$(date --utc +'%Y-%m-%d %H:%M:%S.%N')"
		rc_status
		;;
	    esac
	    #
	    # Let zic set timezone - if present.
	    #
	    if test -n "$TIMEZONE" -a -x /usr/sbin/zic ; then
		echo -n Setting up timezone data
		/usr/sbin/zic -l $TIMEZONE
		rc_status
	    fi

	    rc_status -v
	    rc_exit
	fi
	if test "$ELEVENMIN_MODE" = yes ; then
	    echo "The System Time is in sync with Hardware Clock ${stat}${done}good${norm}"
	    rc_status
	    rc_exit
	fi
	#
	# Set and adjust the hardware clock
	#	
	echo -n "Set System Time to the current Hardware Clock"
	#
	# Read out to hardware clock and for UTC calculate adjtime
	# write back the system time later at reboot/shutdown time.
	#
	if test "$USE_ADJFILE" = yes ; then
	    #
	    # For UTC calculate adjtime
	    #
	    if test ! -s /etc/adjtime ; then
		echo "0.0 0 0.0"
		echo "0"
		echo "UTC"
	    fi >  /etc/adjtime
	    rtc_rule /sbin/hwclock --hctosys $HWCLOCK --adjust
	else
	    # Remove any /etc/adjtime left over
	    test -e /etc/adjtime && rm -f /etc/adjtime
	    rtc_rule /sbin/hwclock --hctosys $HWCLOCK --noadjfile
	fi
	rc_status -v
	;;
    stop)
	if test "$ELEVENMIN_MODE" = yes ; then
	    echo "The System Time is in sync with Hardware Clock ${stat}${done}good${norm}"
	    rc_status
	    rc_exit
	fi
	if test "$USE_HWCLOCK" = yes -a "$SYSTOHC" = yes ; then
	    echo -n "Set Hardware Clock to the current System Time"
	    #
	    # Write system time back to hardware clock
	    #
	    if test "$USE_ADJFILE" = yes ; then
		/sbin/hwclock --systohc $HWCLOCK
	    else
		# Remove any /etc/adjtime left over
		test -e /etc/adjtime && rm -f /etc/adjtime
		/sbin/hwclock --systohc $HWCLOCK --noadjfile
	    fi
	    rc_status -v
	fi
	;;
    timezone)
	echo -n "Set Hardware Clock to the current System Time"
	if test "$USE_HWCLOCK" = yes ; then
	    /sbin/hwclock --systohc $HWCLOCK --noadjfile
	else
	    rc_status -u
	fi
	;;
    status)
	echo -n "Current Hardware Clock: "
	/sbin/hwclock --show
	rc_status -v1
	;;
    *)
	echo "Usage: $0 {start|stop|status|restart|reload|force-reload|timezone}"
	exit 1
	;;
esac

rc_exit
