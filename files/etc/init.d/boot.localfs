#! /bin/sh
#
# Copyright (c) 2001-2002 SuSE Linux AG, Nuernberg, Germany.
# All rights reserved.
#
# /etc/init.d/boot.localfs
#
### BEGIN INIT INFO
# Provides:          boot.localfs
# Required-Start:    boot.udev boot.rootfsck
# Should-Start:      boot.md boot.lvm dasd_devfs_compat boot.scsidev boot.multipath boot.evms boot.loadmodules
# Required-Stop:
# Default-Start:     B
# Default-Stop:
# Short-Description: check and mount local filesystems except /
# Description:       check and mount local filesystems except /
### END INIT INFO

. /etc/rc.status

# to get max number of parallel fsck processes
. /etc/sysconfig/boot
. /etc/sysconfig/kernel
. /etc/sysconfig/sysctl

test -z "$REDIRECT" && REDIRECT="$(showconsole 2>/dev/null)"
export REDIRECT
export FSCK_MAX_INST

#
# Special file systems (memory and network based)
#
typeset -r memfs=tmpfs,devpts,proc,usbfs,sysfs
typeset -r netfs=nfs,nfs4,smbfs,cifs
typeset -r  nofs=no${netfs//,/,no},no${memfs//,/,no}

#
# helper shell function
#
if type -p tac > /dev/null 1>&2 ; then
    reverse ()
    {
	tac
    }
else
    reverse ()
    {
	local line
	while read -r line ; do
	    reverse
	    echo "$line"
	    break
	done
    }
fi

loopdel ()
{
   losetup ${1+"$@"} > /dev/null 2>&1
   test $? -eq 0 || return 0
   losetup -d ${1+"$@"}
}

list_missed ()
{
    local dev line
    local mount_opts="-t $nofs -O no_netdev"

    mount -afnv $mount_opts 2> /dev/null | while read line ; do
	dev="${line%% *}"
	case "$line" in
	*mounted*)
	    continue	  ;;
	*)  test -b $dev && continue
	    echo "${dev}" ;;
	esac
    done
}

wait_for_udev ()
{
    local dev
    local -i timeout=30
    local missing=$(list_missed)

    test -n "$missing" || return 0
    echo -n "Waiting for $missing "
    while test $timeout -gt 0 ; do
	sleep 1
	echo -n "."
	still_missing=""
	for dev in $missing; do
	    if test ! -b $dev ; then
		still_missing="$dev $still_missing"
	    fi
	done
	if test -z "$still_missing" ; then
	    echo " ok"
	    break
	fi
	missing="$still_missing"
	if test ! -d /dev/.udev/queue ; then
	    echo " no more events"
	    break
	fi
	let timeout--
    done
    test $timeout -eq 0 && echo " timeout! "
}

rc_reset

case "$1" in
  start)
	# handle DMAPI_PROBE here, boot.sysctl is too late
	if test "$DMAPI_PROBE" = "yes" ; then
	    test -d /proc/sys/fs/xfs || modprobe xfs
	    test -e /proc/sys/fs/xfs/probe_dmapi && echo 1 > /proc/sys/fs/xfs/probe_dmapi
	fi

	# rootfs is mounted rw, lvm et al should be up now
	wait_for_udev
	#
	# If we use a serial console, don't use the fsck progress bar
	#
	FSCK_PROGRESSBAR="-V"
	test "$REDIRECT" = "/dev/tty1" && FSCK_PROGRESSBAR="-C"
	#
	# do fsck and start sulogin, if it fails.
	#
	FSCK_RETURN=0
	if test ! -f /fastboot -a -z "$fastboot" ; then
	    FSCK_FORCE=""
	    test -f /forcefsck && FSCK_FORCE="-f"
	        echo "Checking file systems..."
	        fsck $FSCK_PROGRESSBAR -R -A -M -a $FSCK_FORCE -t noopts=nofail
	        # A return code of 1 indicates that file system errors
	        # were corrected, but that the boot may proceed.
	        # A return code of 2 or larger indicates failure.
	        FSCK_RETURN=$?
		test $FSCK_RETURN -lt 4
		rc_status -v1 -r
		if test $FSCK_RETURN -gt 1 -a $FSCK_RETURN -lt 4 ; then
		    # if appropriate, switch bootsplash to verbose 
		    # mode to make text messages visible.
		    test -f /proc/splash && echo "verbose" > /proc/splash
		    echo
		    echo "fsck succeed, but reboot is required."
		    echo
		    sleep 1
		    sync
		    reboot -f
		elif test $FSCK_RETURN -gt 3; then
		    # if appropriate, switch bootsplash to verbose 
		    # mode to make text messages visible.
		    test -f /proc/splash && echo "verbose" > /proc/splash
		    # Stop blogd since we reboot after sulogin
		    test -x /sbin/blogd && killproc -QUIT /sbin/blogd
		    if test -x /etc/init.d/kbd ; then
			/etc/init.d/kbd start
		    fi
	            echo
	            echo "fsck failed for at least one filesystem (not /)."
		    echo "Please repair manually and reboot."
		    echo "The root file system is is already mounted read-write."
	            echo
	            echo "Attention: Only CONTROL-D will reboot the system in this"
	            echo "maintanance mode. shutdown or reboot will not work."
	            echo
	            PS1="(repair filesystem) # "
	            export PS1
	            /sbin/sulogin /dev/console

	            # if the user has mounted something rw, this should be umounted
	            echo "Unmounting file systems (ignore error messages)"
	            umount -avn

	            # on umsdos fs this would lead to an error message.
		    # so direct errors to /dev/null
	            mount -no remount,ro / 2> /dev/null

	            sync
	            reboot -f
	        fi
	        if test $FSCK_RETURN -gt 0; then
	            sync
		    touch /fsck_corrected_errors
		fi
	fi

	#
	# clean up
	#
	rm -f /etc/nologin /nologin /fastboot /forcefsck /success

	rc_status -v -r

	#
	# Mount local filesystems in '/etc/fstab' (and create an entry
	# for / and /proc).
	#
	echo "Mounting local file systems..."
	mount -fv -t proc proc /proc
	mount -fv -t sysfs sysfs /sys
	# remount to make sure options from fstab are honoured
	mount -oremount /proc
	mount -oremount /sys
	while read a b ; do
	    if test "$b" = "debugfs" ; then
		mount -fv -t debugfs debugfs /sys/kernel/debug
	    fi
	done < /proc/filesystems
	mount -fv -t tmpfs udev /dev
	rc_status
	if test ! -d /sys/block/loop0 ; then
	    /sbin/modprobe loop
	fi
	optpts="-o mode=0620,gid=5"
	mount -fv -t devpts $optpts devpts /dev/pts
	rc_status
	mount -av -t $nofs -O no_netdev
	rc_status -v1 -r
	;;
    stop)
	mounts=/etc/fstab
	test -r /proc/mounts && mounts=/proc/mounts

	mtab=
	test "$2" = "nomtab" && mtab=-n

	# move to intermezzo package ?
	# First umount intermezzo filesystems
	if type -p umountizo > /dev/null 1>&2 ; then
	    while read line ; do
		case "$line" in
		*[Ii][Nn][Tt][Ee][Rr][Mm][Ee][Zz][Zz][Oo]*)
		    umountizo >/dev/null 2>&1
		esac
	    done < $mounts
	fi

	reverse < $mounts | \
	while read des fs type rest; do
	    case "${des##*/}"  in
		""|\#*)    continue ;;
		loop*)	   umount $mtab $fs
			   loopdel $des ;;
	    esac
	    case "$fs"   in
		/sys*)     continue ;;
		/proc*)    continue ;;
		/dev*)     continue ;;
	    esac
	    case ",$memfs," in
		*,$type,*) umount $mtab -t $type $fs ;;
	    esac
	done

	grep "loop" /proc/partitions | while read major minor blocks name ; do
	    case "$name" in
		loop*)	   loopdel /dev/loop/${name#loop}
			   loopdel /dev/$name ;;
	    esac
	done

	UMOUNT_FAILED=false
	echo "Unmounting file systems"
	umount -av $mtab -t $nofs -O no_netdev || {
	    rc_status
	    UMOUNT_FAILED=true
	}
	rc_status -v1 -r

	if test "$UMOUNT_FAILED" = true -a -z "$mtab" ; then
	    echo "Oops: umount failed :-(  --  trying to remount readonly..."
	    mounts=/etc/fstab
	    test -r /proc/mounts && mounts=/proc/mounts
	    # Use cat and a pipe because umount changes
	    # /proc/mounts during direct read call
	    cat $mounts | \
	    while read des fs type rest; do
	        case "$des" in
		    ""|\#*)	continue ;; Comment
		    swap)	continue ;; No umount on swap devices
		esac
		case ",$memfs," in
		    *,$type,*)	continue ;; Most of them are required
		esac
		case ",$netfs," in
		    *,$type,*)	continue ;; Avoid hanging reboot/halt
		esac
		mount -v -n -o remount,ro $fs
	    done

	    echo "extra sync..."
	    sync; sleep 1; sync
	    echo "... hope now it's ok to reboot."
	fi
	;;
    restart)
	rc_failed 3
	rc_status -v
	;;
    status)
	rc_failed 4
	rc_status -v
	;;
    *)
	echo "Usage: $0 {start|stop|status|restart}"
	exit 1
	;;
esac

rc_exit

