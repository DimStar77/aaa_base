#! /bin/bash
# Copyright (c) 1996 S.u.S.E. GmbH Fuerth, Germany.  All rights reserved.
#
# Author: Burchard Steinbild <bs@suse.de>, 1996
#         Werner Fink <werner@suse.de>, 1996,97
#      
#
# /sbin/init.d/route		Version 0.3
#

. /etc/rc.config

: ${ROUTECONF:=/etc/route.conf}
declare -i n

reverse ()
{
    local _R
    (
	if read -r _R ; then
	    reverse
	    echo -e "$_R"
	fi
    )
}

run_route ()
{
    local command="/sbin/route $@"
    $command
    test $? = 0 || echo -e "\033[1mError while excuting:\n    $command\033[m"
}

case "$1" in
    start)
	if test -n "$NETCONFIG" -a "$NETCONFIG" != "YAST_ASK" -a \
		-f $ROUTECONF ; then
	    echo "Setting up routing (using ${ROUTECONF})."
	    #
	    # Read possible devices out of /proc/net/dev
	    #
	    n=0
	    while read proc ; do
    		n=$((n + 1))
    		if test $n -gt 2 ; then
		    given="${given} ${proc%:*}"
    		fi
	    done < /proc/net/dev
	    #
	    # Read /etc/route.conf and add routings
	    #
	    while read  des what mask iface  ; do
		case "$des" in
		\#*|"") ;;
		224.0.0.0)
		    # We are doing multicast
		    if test -e /proc/net/igmp -a \
			    "$what" = 0.0.0.0 -a "$mask" = 240.0.0.0 ; then
			echo "Add multicast route 240.0.0.0 for $iface"
			run_route add -net 224.0.0.0 netmask 240.0.0.0 dev $iface
		    else
			echo "Skipping multicast route 240.0.0.0 for $iface"
			test ! -e /proc/net/igmp  && \
			    echo "  no /proc/net/igmp available"
			test "$what" != 0.0.0.0   && \
			    echo "  wrong dummy entry $what in $ROUTECONF"
			test "$mask" != 240.0.0.0 && \
			    echo "  wrong netmask entry $mask in $ROUTECONF"
			sleep 2
		    fi
		    ;;
		*)
		    card=""
		    test -n "$iface" && card="dev $iface"
		    case "$what" in
		    "")
			echo "Wrong entry in ${ROUTECONF}"
			echo ">> $des $what $mask $iface"
			sleep 2
			;;
		    0.0.0.0|\*)          # Add a local Network
			if test -z "$mask" -o -z "$iface" ; then
			    echo "Wrong entry in ${ROUTECONF}"
			    echo ">> $des $what $mask $iface"
			    sleep 2
			fi
			for dev in $given ; do
			    case "$iface" in
			    $dev)
				if test "${mask}" = 255.255.255.255 ; then
				    # ISDN/PPP auto dial
				    run_route add -host "${des}" $card
				else
				    run_route add -net  "${des}" netmask "${mask}" $card
				fi
				;;
			    esac
			done
			;;
		    *)
			case "$mask" in
			0.0.0.0|"")      # Add Gateway
			    run_route add "${des}" gw "${what}" $card
			    ;;
			255.255.255.255) # Add a Host by a Gateway/Route
			    if test "$des" = "$what" ; then
				run_route add -host "${des}" $card
			    else
				run_route add -host "${des}" gw "${what}" $card
			    fi
			    ;;
			*.*.*.*)         # Add a Network
			    run_route add -net "${des}" netmask "${mask}" gw "$what" $card
			    ;;
			*)
			    echo "Wrong entry in ${ROUTECONF}"
			    echo ">> $des $what $mask $iface"
			    sleep 2
			esac
		    esac
		esac
	    done < $ROUTECONF
	fi
	;;
    stop)
	if test -n "$NETCONFIG" -a "$NETCONFIG" != "YAST_ASK" ; then
	    ONEWAY=false
	    test "$RUNLEVEL" = "0" -o "$RUNLEVEL" = "6" && ONEWAY=true
	    if test "$CLOSE_CONNECTIONS" = "true" -a "$ONEWAY" = "true" ; then
		echo "Close all net connections."
		#
		# Close all net connection with SIGTERM
		#
		n=0
		tports=""
		uports=""
		dosleep=no
		while read prot resv send loc rest ; do
		    n=$((n + 1))
		    if test $n -gt 2 ; then
			test "$prot" = "tcp" && tports="${tports} ${loc#*:}"
			test "$prot" = "udp" && uports="${uports} ${loc#*:}"
		    fi
		done < <(netstat -n -tu)
		if [ -n "${tports}" ] ; then
		    fuser -n tcp -TERM -k ${tports} > /dev/null
		    dosleep=yes
		fi
		if [ -n "${uports}" ] ; then
		    fuser -n udp -TERM -k ${uports} > /dev/null
		    dosleep=yes
		fi
		[ $dosleep = yes ] && sleep 5
	    fi
	    echo "Shutting down routing."
	    #
	    # Read possible devices out of /proc/net/dev
	    #
	    n=0
	    while read proc ; do
    		n=$((n + 1))
    		if test $n -gt 2 ; then
		    given="${given} ${proc%:*}"
    		fi
	    done < /proc/net/dev
	    #
	    # Read /etc/route.conf reverse and delete routings
	    #
	    reverse < $ROUTECONF | \
	    while read  des what mask iface  ; do
		case "$des" in
		\#*|"") ;;
		224.0.0.0)
		    # We are doing multicast
		    if test -e /proc/net/igmp -a \
			    "$what" = 0.0.0.0 -a "$mask" = 240.0.0.0 ; then
			echo "Delete multicast route 240.0.0.0 for $iface"
			run_route del -net 224.0.0.0 netmask 240.0.0.0 dev $iface
		    else
			echo "Skipping multicast route 240.0.0.0 for $iface"
			test ! -e /proc/net/igmp  && \
			    echo "  no /proc/net/igmp available"
			test "$what" != 0.0.0.0   && \
			    echo "  wrong dummy entry $what in $ROUTECONF"
			test "$mask" != 240.0.0.0 && \
			    echo "  wrong netmask entry $mask in $ROUTECONF"
			sleep 2
		    fi
		    ;;
		*)
		    card=""
		    test -n "$iface" && card="dev $iface"
		    case "$what" in
		    "")
			echo "Wrong entry in ${ROUTECONF}"
			echo ">> $des $what $mask $iface"
			sleep 2
			;;
		    0.0.0.0|\*)          # Delete a local Network
			if test -z "$mask" -o -z "$iface" ; then
			    echo "Wrong entry in ${ROUTECONF}"
			    echo ">> $des $what $mask $iface"
			    sleep 2
			fi
			for dev in $given ; do
			    case "$iface" in
			    $dev)
				if test "${mask}" = 255.255.255.255 ; then
				    # ISDN/PPP auto dial
				    run_route del -host "${des}" $card
				else
				    run_route del -net  "${des}" netmask "${mask}" $card
				fi
				;;
			    esac
			done
			;;
		    *)
			case "$mask" in
			0.0.0.0|"")      # Delete Gateway
			    run_route del "${des}" gw "${what}" $card
			    ;;
			255.255.255.255) # Delete a Host by a Gateway/Route
			    if test "$des" = "$what" ; then
				run_route del -host "${des}" $card
			    else
				run_route del -host "${des}" gw "${what}" $card
			    fi
			    ;;
			*.*.*.*)         # Delete a Network
			    run_route del -net "${des}" netmask "${mask}" gw "$what" $card
			    ;;
			*)
			    echo "Wrong entry in ${ROUTECONF}"
			    echo ">> $des $what $mask $iface"
			    sleep 2
			esac
		    esac
		esac
	    done
	fi
	;;
    *)
	echo "Usage: $0 {start|stop}"
	exit 1
esac


exit 0
