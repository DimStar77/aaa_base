#! /bin/sh
#
# Copyright (c) 1996 SuSE GmbH Nuernberg, Germany.  All rights reserved.
#
# Author: Florian La Roche <florian@suse.de>, 1996
#         Werner Fink <werner@suse.de>, 1996
#         Burchard Steinbild <bs@suse.de>, 1996
#
# /sin/init.d/boot
#
# first script to be executed from init on system startup
#

. /etc/rc.config
echo "Running $0"

ECHO_RETURN=$rc_done
echo -n "Mounting /proc device"
mount -n -t proc proc /proc || ECHO_RETURN=$rc_failed
echo -e "$ECHO_RETURN"


#
# possibly there are file systems on devices, which need a kernel 
# module to be loaded.  So start kerneld as early as possible.
#
if test "$START_KERNELD" = yes -a \
        -x /sbin/kerneld -a ! -e /proc/sys/kernel/modprobe ; then
    ECHO_RETURN=$rc_done_up
    /sbin/kerneld || ECHO_RETURN=$rc_failed_up
    echo -e "$ECHO_RETURN"
fi

#
# maybe we use "Multiple devices".  So initialize MD.
#
if test -f /etc/mdtab -a -x /sbin/mdadd ; then
    ECHO_RETURN=$rc_done_up
    echo "Initializing Multiple Devices..."
    /sbin/mdadd -ar && MDADD_RETURN=0 || MDADD_RETURN=1
    if test $MDADD_RETURN != 0 ; then
        if test  -x /sbin/ckraid ; then
            echo "Initializing Multiple Devices failed.  Trying to recover it..."
            for i in /etc/raid?.conf ; do
                /sbin/ckraid --fix $i
            done
            /sbin/mdadd -ar || ECHO_RETURN=$rc_failed_up
        else
            ECHO_RETURN=$rc_failed_up
        fi
    fi
    echo -e "$ECHO_RETURN"
fi

#
# fsck can need a huge amount of memory, so make sure, it is there.
#
ECHO_RETURN=$rc_done_up
echo "Activating swap-devices in /etc/fstab..."
swapon -a || ECHO_RETURN=$rc_failed_up
echo -e "$ECHO_RETURN"


#
# you will need "update".
#
ECHO_RETURN=$rc_done
echo -n "Running update (bdflush) daemon"
/sbin/update || ECHO_RETURN=$rc_failed
echo -e "$ECHO_RETURN"

#
# do fsck and start sulogin, if it fails.
#
FSCK_RETURN=0
if test ! -f /fastboot -a -z "$fastboot" ; then
    # on an umsdos root fs this mount will fail, so direct error messages 
    # to /dev/null.
    # this seems to be ugly, but should not really be a problem.
    mount -n -o remount,ro / 2> /dev/null
    if test $? = 0; then
        ECHO_RETURN=$rc_done_up
        echo "Checking file systems..."
        fsck -A -a
        # A return code of 1 indicates that file system errors
        # were corrected, but that the boot may proceed.
        # A return code of 2 or larger indicates failure.
        FSCK_RETURN=$?
        if test $FSCK_RETURN -gt 1; then
            echo -e "$rc_failed_up"
            if test -x /sbin/init.d/kbd ; then
                /sbin/init.d/kbd start
            fi
            echo
            echo "fsck failed.  Please repair manually and reboot. The root"
            echo "file system is currently mounted read-only. To remount it"
            echo "read-write do:"
            echo
            echo "   bash# mount -n -o remount,rw /"
            echo
            echo "Attention: Only CONTROL-D will reboot the system in this"
            echo "maintanance mode. shutdown or reboot will not work."
            echo
            PS1="(repair filesystem) # "
            export PS1
            # XXX /sbin/sulogin /dev/console
            /sbin/sulogin /dev/tty1

            # if the user has mounted something rw, this should be umounted
            echo "Unmounting file systems (ignore error messages)"
            umount -avn

            # on umsdos fs this would lead to an error message. so direct 
            # errors to /dev/null
            mount -no remount,ro / 2> /dev/null

            sync
            reboot -f
        fi
        echo -e "$ECHO_RETURN"
        sync
        mount -n -o remount,rw /
    else
	mounts=/etc/mtab
	test -r /proc/mounts && mounts=/proc/mounts
	while read des fs type rest; do
	    case "$fs" in
	        /) break ;;
	        *)       ;;
	    esac
	done < $mounts

	if test "$type" != "umsdos" ; then
	    echo
	    echo "*** ERROR!  Cannot fsck because root is not read-only!"
	    echo
	fi
    fi
else
    echo "File systems are NOT being checked."
    mount -n -o remount,rw /
fi

#
# clean up
#
rm -f /etc/mtab* /etc/nologin /nologin /fastboot

#
# initialize database for kerneld.  This should be done earlier, but
# could cause a lot of trouble with damaged file systems.
# restart of kerneld will be done by /sbin/init.d/kerneld
# 
MODULES_DIR=/lib/modules/`uname -r` 
if test -x /sbin/depmod -a -d $MODULES_DIR ; then
    ECHO_RETURN=$rc_done
    for i in $MODULES_DIR/* $MODULES_DIR/*/* /etc/conf.modules ; do
        test -e $i || continue
        if test $i -nt $MODULES_DIR/modules.dep ; then
            rm -f $MODULES_DIR/modules.dep
            break
        fi
    done
    if test ! -e $MODULES_DIR/modules.dep ; then
        echo -n Setting up $MODULES_DIR
        /sbin/depmod -a 2> /dev/null > /dev/null || ECHO_RETURN=$rc_failed
        echo -e "$ECHO_RETURN"
    fi
fi

#
# Mount local filesystems in '/etc/fstab' (and create an entry 
# for / and /proc).
#
ECHO_RETURN=$rc_done_up
echo "Mounting local file systems..."
mount -fv -t proc proc /proc || ECHO_RETURN=$rc_failed_up
mount -av -t nonfs,noproc || ECHO_RETURN=$rc_failed_up
echo -e "$ECHO_RETURN"

#
# reinit quota, if fsck has returned value != 0
#
if test $FSCK_RETURN -gt 0 -a -n "$START_QUOTA" -a "$START_QUOTA"="yes" ; then
    # Check quota and then turn quota on.
    if test -x /sbin/quotacheck ; then
        ECHO_RETURN=$rc_done_up
        echo "Checking quotas. This may take some time."
        /sbin/quotacheck -avug || ECHO_RETURN=$rc_failed_up
        echo -e "$ECHO_RETURN"
    fi
fi

# Let ld.so rebuild its cache.
test -x /sbin/ldconfig && {
    ECHO_RETURN=$rc_done
    echo -n "Setting up /etc/ld.so.cache"
    /sbin/ldconfig -X 2>/dev/null || ECHO_RETURN=$rc_failed
    echo -e "$ECHO_RETURN"
}

#
# Let zic set timezone - if present.
#
if test -n "$TIMEZONE" -a "$TIMEZONE" != "YAST_ASK" -a -x /usr/sbin/zic ; then
    ECHO_RETURN=$rc_done
    echo -n Setting up timezone data
    /usr/sbin/zic -l $TIMEZONE || ECHO_RETURN=$rc_failed
    echo -e "$ECHO_RETURN"
fi

#
# initialize loopback device
#
if test "$START_LOOPBACK" = yes; then
        ECHO_RETURN=$rc_done
        echo -n Setting up loopback device
        ifconfig lo 127.0.0.1 netmask 255.0.0.0 up || ECHO_RETURN=$rc_failed
        route add -net 127.0.0.0 netmask 255.0.0.0 dev lo || ECHO_RETURN=$rc_failed
        echo -e "$ECHO_RETURN"
fi

#
# set hostname and domainname
#
test -n "$FQHOSTNAME" && {
    ECHO_RETURN=$rc_done
    echo -n Setting up hostname
    hostname ${FQHOSTNAME%%.*} || ECHO_RETURN=$rc_failed
    echo -e "$ECHO_RETURN"
}
test -n "$YP_DOMAINNAME" && {
    ECHO_RETURN=$rc_done
    echo -n Setting YP up domainname
    domainname $YP_DOMAINNAME || ECHO_RETURN=$rc_failed
    echo -e "$ECHO_RETURN"
}


# set and adjust the CMOS clock
echo -n Setting up the CMOS clock
ECHO_RETURN=$rc_done
test "$GMT" != "YAST_ASK" && hwclock -s $GMT || ECHO_RETURN=$rc_failed
test -f /etc/adjtime || echo "0.0 0 0.0" > /etc/adjtime
test "$GMT" != "YAST_ASK"  -a "$START_XNTPD" != "yes" && {
    hwclock -a $GMT || ECHO_RETURN=$rc_failed
}
echo -e "$ECHO_RETURN"


#
# clean up
#
rm -f /var/lock/* /var/lock/*/* /tmp/.X*lock \
      /var/run/*  /var/run/*/*  /var/spool/uucp/LCK* 2>/dev/null

rm -f /var/run/utmp
echo -n > /var/run/utmp
chmod 664 /var/run/utmp
chown root.tty /var/run/utmp

#
# there could be a new kernel version.  reinit /etc/psdevtab, to be sure.
#
rm -f /etc/psdevtab
test -x /bin/ps && /bin/ps > /dev/null 2> /dev/null

#
# start bootup client scripts.
#
if test -d /sbin/init.d/boot.d; then
        for i in /sbin/init.d/boot.d/S*; do
                test -f $i || continue
                echo Running $i
                ECHO_RETURN=$rc_done_up
                test -f "$i" && {
                    /bin/sh $i b || ECHO_RETURN=$rc_failed_up
                }
                echo -e "$ECHO_RETURN"
        done
fi

#
# setup PNP if config file is present
#
if test -r /etc/isapnp.conf -a -x /sbin/isapnp -a "$START_ISAPNP" = yes ; then
    ECHO_RETURN=$rc_done_up
    echo "Initializing PnP devices"
    /sbin/isapnp /etc/isapnp.conf || ECHO_RETURN=$rc_failed_up
    echo -e "$ECHO_RETURN"
fi

#
# start user defined bootup script.
#
if test -f /sbin/init.d/boot.local ; then
        ECHO_RETURN=$rc_done_up
        echo "Running /sbin/init.d/boot.local"
        /bin/sh /sbin/init.d/boot.local || ECHO_RETURN=$rc_failed_up
        echo -e "$ECHO_RETURN"
fi

# Read all kernel messages generated until now and put them in one file.
if test -x /usr/sbin/klogd ; then
        ECHO_RETURN=$rc_done_up
        echo Creating /var/log/boot.msg
        rm -f /var/log/boot.msg
        /usr/sbin/klogd -f /var/log/boot.msg -o 
        /bin/sleep 1
        test -s /var/log/boot.msg || ECHO_RETURN=$rc_failed_up
        echo -e "$ECHO_RETURN"
fi

#
# enable DEXE binary format
#
if test -d /proc/sys/fs/binfmt_misc -a -x /usr/bin/dosexec; then
  ECHO_RETURN=$rc_done
  echo -n "Registering DEXE for binfmt"
  echo :DEXE:M::\\x0eDEXE::/usr/bin/dosexec: > \
    /proc/sys/fs/binfmt_misc/register || ECHO_RETURN=$rc_failed
  echo -e "$ECHO_RETURN"
fi

#
# Enable "dynamic IP patch"
#
if test -n "$IP_DYNIP" -a "$IP_DYNIP" != no -a \
    -e /proc/sys/net/ipv4/ip_dynaddr ; then
    echo -n "Enabling dynamic IP patch"
    case "$IP_DYNIP" in
	yes)    echo 7         ; ECHO_RETURN=$rc_done ;;
	[1-9])  echo $IP_DYNIP ; ECHO_RETURN=$rc_done ;;
	*)      ECHO_RETURN=" invalid IP_DYNIP=$IP_DYNIP $rc_skipped" ;;
    esac > /proc/sys/net/ipv4/ip_dynaddr || ECHO_RETURN=$rc_failed
    echo -e "$ECHO_RETURN"
fi

#
# Enable syn flood protection
#
if test -n "$IP_TCP_SYNCOOKIES" -a "$IP_TCP_SYNCOOKIES" != no -a \
    -e /proc/sys/net/ipv4/tcp_syncookies ; then
    echo -n "Enabling syn flood protection"
    case "$IP_TCP_SYNCOOKIES" in
        yes)    echo 1         ; ECHO_RETURN=$rc_done ;;
        *)      ECHO_RETURN=" invalid IP_TCP_SYNCOOKIES=$IP_TCP_SYNCOOKIES $rc_skipped" ;;
    esac > /proc/sys/net/ipv4/tcp_syncookies || ECHO_RETURN=$rc_failed
    echo -e "$ECHO_RETURN"
fi


#
# Enable IP forwarding ?
#
if test -e /proc/sys/net/ipv4/ip_forward -a -n "$IP_FORWARD" ; then
    ECHO_RETURN=$rc_done
    case $IP_FORWARD in
      yes)
        echo -n "Enabling IP forwarding"
        echo "1" > /proc/sys/net/ipv4/ip_forward || ECHO_RETURN=$rc_failed
      ;;
      *)
        echo -n "Disabling IP forwarding"
        echo "0" > /proc/sys/net/ipv4/ip_forward || ECHO_RETURN=$rc_failed
      ;;
    esac
    echo -e "$ECHO_RETURN"
fi

#
# insert memstat module for xosview
#
if test -f $MODULES_DIR/misc/memstat.o ; then
    ECHO_RETURN=$rc_done_up
    echo Loading memstat module
    insmod $MODULES_DIR/misc/memstat.o || ECHO_RETURN=$rc_failed_up
    echo -e "$ECHO_RETURN"
fi

#
# look for stuff to do for first bootup.
#
if test -e /var/adm/setup/setup.newinst -o -e /usr/lib/YaST/.configured2 ; then
    if test -w / -a "$NO_AUTO_SETUP" != true ; then
        if test -e /usr/lib/YaST/.configured2 ; then
            echo
            echo It seems, that last installation setup has not been finished...
            echo To be sure, it will be started again.
            echo
            sleep 2
            rm -f /usr/lib/YaST/.configured2
        fi
        /lib/YaST/bootsetup
        #
        # maybe YaST has started gpm. This can lead into trouble with
        # setserial.  Since it is started again, when entering into
        # runlevel 2, we can kill it here.
        #
        killproc -TERM /usr/bin/gpm > /dev/null 2> /dev/null
    fi
fi


exit 0
