#! /bin/sh
#
# Copyright (c) 1996 S.u.S.E. GmbH Fuerth, Germany.  All rights reserved.
#
# Author: Florian La Roche <florian@suse.de>, 1996
#         Werner Fink <werner@suse.de>, 1996
#         Burchard Steinbild <bs@suse.de>, 1996
#
# /sin/init.d/boot
#
# first script to be executed from init on system startup
#

. /etc/rc.config
echo "Running $0."

echo "Mounting /proc device..."
mount -nv -t proc proc /proc

#
# possibly there are file systems on devices, which need a kernel 
# module to be loaded.  So start kerneld as early as possible.
#
if test "$START_KERNELD" = yes -a \
        -x /sbin/kerneld -a ! -e /proc/sys/kernel/modprobe ; then
    /sbin/kerneld
fi

#
# maybe we use "Multiple devices".  So initialize MD.
#
if test -f /etc/mdtab -a -x /sbin/mdadd ; then
    echo "Initializing Multiple Devices..."
    /sbin/mdadd -ar
    if test $? != 0 -a -x /sbin/ckraid ; then
        echo "Initializing Multiple Devices failed.  Trying to recover it..."
        for i in /etc/raid?.conf ; do
            /sbin/ckraid --fix $i
        done
        /sbin/mdadd -ar
    fi
fi

#
# fsck can need a huge amount of memory, so make sure, it is there.
#
echo "Activating swap-devices in /etc/fstab..."
swapon -a

#
# you will need "update".
#
echo "Running update (bdflush) daemon."
/sbin/update


#
# do fsck and start sulogin, if it fails.
#
FSCK_RETURN=0
if test ! -f /fastboot -a -z "$fastboot" ; then
    # on an umsdos root fs this mount will fail, so direct error messages 
    # to /dev/null.
    # this seems to be ugly, but should not really be a problem.
    mount -n -o remount,ro / 2> /dev/null
    if test $? = 0; then
        echo "Checking file systems..."
        fsck -A -a
        # A return code of 1 indicates that file system errors
        # were corrected, but that the boot may proceed.
        # A return code of 2 or larger indicates failure.
        FSCK_RETURN=$?
        if test $FSCK_RETURN -gt 1; then
            if test -f /etc/default.keytab -a -x /bin/loadkeys; then
                /bin/loadkeys /etc/default.keytab
            fi
            echo
            echo "fsck failed.  Please repair manually and reboot. The root"
            echo "file system is currently mounted read-only. To remount it"
            echo "read-write do:"
            echo
            echo "   bash# mount -n -o remount,rw /"
            echo
            echo "Attention: Only CONTROL-D will reboot the system in this"
            echo "maintanance mode. shutdown or reboot will not work."
            echo
            PS1="(repair filesystem) # "
            export PS1
            # XXX /sbin/sulogin /dev/console
            /sbin/sulogin /dev/tty1

            # if the user has mounted something rw, this should be umounted
            echo "Unmounting file systems (ignore error messages)"
            umount -avn

            # on umsdos fs this would lead to an error message. so direct 
            # errors to /dev/null
            mount -no remount,ro / 2> /dev/null

            sync
            reboot
        fi
        sync
        mount -n -o remount,rw /
    else
        if test ! -d /DOS ; then # this is a hack - we need a better
                                 # recognization of umsdos root fs
            echo
            echo "*** ERROR!  Cannot fsck because root is not read-only!"
            echo
        fi
    fi
else
    echo "File systems are NOT being checked."
    mount -n -o remount,rw /
fi

#
# clean up
#
rm -f /etc/mtab* /etc/nologin /nologin /fastboot

#
# initialize database for kerneld.  This should be done earlier, but
# could cause a lot of trouble with damaged file systems.
# restart of kerneld will be done by /sbin/init.d/kerneld
# 
MODULES_DIR=/lib/modules/`uname -r` 
if test "$START_KERNELD" = yes -a \
        -x /sbin/depmod -a ! -e /proc/sys/kernel/modprobe ; then
    if test -d $MODULES_DIR ; then
        /sbin/depmod -a 2> /dev/null > /dev/null
    fi
fi

#
# Mount local filesystems in '/etc/fstab' (and create an entry 
# for / and /proc).
#
echo "Mounting local file systems..."
mount -fv -t proc proc /proc
mount -av -t nonfs,noproc

#
# reinit quota, if fsck has returned value != 0
#
if test $FSCK_RETURN -gt 0 -a -n "$START_QUOTA" -a "$START_QUOTA"="yes" ; then
      # Check quota and then turn quota on.
      if test -x /sbin/quotacheck ; then
          echo "Checking quotas. This may take some time."
          /sbin/quotacheck -avug
          echo " Done."
      fi
fi

# Let ld.so rebuild its cache.
test -x /sbin/ldconfig && /sbin/ldconfig -X 2>/dev/null

# XXX write reboot record here and delete the code in /sbin/init...

#
# initialize loopback device
#
if test "$START_LOOPBACK" = yes; then
        ifconfig lo 127.0.0.1 netmask 255.0.0.0 up
        route add -net 127.0.0.0 netmask 255.0.0.0 dev lo
fi

#
# start bootup client scripts.
#
if test -d /sbin/init.d/boot.d; then
        for i in /sbin/init.d/boot.d/S*; do
                test -f "$i" && /bin/sh $i b
        done
fi

#
# set hostname and domainname
#
test -n "$FQHOSTNAME" && hostname ${FQHOSTNAME%%.*}
test -n "$YP_DOMAINNAME" && domainname $YP_DOMAINNAME


# set and adjust the CMOS clock
test "$GMT" != "YAST_ASK" && hwclock -s $GMT
test -f /etc/adjtime || echo "0.0 0 0.0" > /etc/adjtime
test "$GMT" != "YAST_ASK"  -a "$START_XNTPD" != "yes" && hwclock -a $GMT

#
# clean up
#
rm -f /var/run/utmp
echo -n > /var/run/utmp
chmod 664 /var/run/utmp
chown root.tty /var/run/utmp

rm -f /var/lock/* /var/lock/*/* /tmp/.X*lock \
      /var/run/syslogd.pid /var/spool/uucp/LCK* 2>/dev/null

# The following script is executed at boot-up and also from a cron-entry
# in the early morning. So your system should be checked often enough.
#if test -x /root/bin/cron.daily; then
#        /root/bin/cron.daily
#fi

#
# setup PNP if config file is present
#
if test -r /etc/isapnp.conf -a -x /sbin/isapnp -a "$START_ISAPNP" = yes ; then
    echo "Initializing PnP devices."
    /sbin/isapnp /etc/isapnp.conf
fi

#
# start user defined bootup script.
#
if test -f /sbin/init.d/boot.local ; then
        /bin/sh /sbin/init.d/boot.local
fi

# Read all kernel messages generated until now and put them in one file.
if test -x /usr/sbin/klogd ; then
        /usr/sbin/klogd -f /var/log/boot.msg -o
        /bin/sleep 1
fi

#
# enable DEXE binary format
#
if test -d /proc/sys/fs/binfmt_misc ; then
  echo "Registering DEXE for binfmt..."
  ( cd /proc/sys/fs/binfmt_misc; \
    echo :DEXE:M::\\x0eDEXE::/usr/bin/dosexec: >register )
fi

#
# Enable "dynamic IP patch"
#
if test "$IP_DYNIP" = yes -a -e /proc/sys/net/ipv4/ip_dynaddr ; then
    echo Enabling dynamic IP patch...
    echo 7 > /proc/sys/net/ipv4/ip_dynaddr
fi

#
# insert memstat module for xosview
#
if test -f $MODULES_DIR/misc/memstat.o ; then
    echo Loading memstat module...
    insmod $MODULES_DIR/misc/memstat.o
fi

#
# look for stuff to do for first bootup.
#
if test -e /var/adm/setup/setup.newinst -o -e /usr/lib/YaST/.configured2 ; then
    if test -w / -a "$NO_AUTO_SETUP" != true ; then
        if test -e /usr/lib/YaST/.configured2 ; then
            echo
            echo It seems, that last installation setup has not been finished...
            echo To be sure, it will be started again.
            echo
            sleep 2
            rm -f /usr/lib/YaST/.configured2
        fi
        /lib/YaST/bootsetup
        #
        # maybe YaST has started gpm. This can lead into trouble with
        # setserial.  Since it is started again, when entering into
        # runlevel 2, we can kill it here.
        #
        killproc -TERM /usr/bin/gpm > /dev/null 2> /dev/null
    fi
fi

exit 0
