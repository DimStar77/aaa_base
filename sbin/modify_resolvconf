#!/bin/bash
#
# Copyright (c) 2001 SuSE GmbH Nuernberg, Germany.  All rights reserved.
# Author: Christian Zoz <zoz@suse.de>
#
# TODO:
# -> usage of private extension not implemented
#    - perhaps use it for two-stage backup when dialing on demand
# -> Perhaps respect START_NAMED?

RESOLVCONF=/etc/resolv.conf
PROGNAME=`basename $0`
TMPFILE=`mktemp /tmp/mdfrc.XXXXXX`
TMPRC=`mktemp /tmp/resolv.conf.XXXXXX`
RETVAL=0

usage () {
  cat << EOT
  usage:   $PROGNAME <action> <options>
  action:  modify, restore, cleanup or check
  options:                               mandatory for:
    -s|--service <service>               modify, restore
    -p|--process <process>               modify
    -i|--pid <pid>
    -f|--script <pathname of script>     modify
    -t|--text <text>                     modify
    -l|--searchlist <list of domains>
    -d|--domain <domain>
    -n|--nameservers <addresses>
    -o|--save_now <pathname of file>
    -a|--save_later <pathname of file>
    -k|--keep
    -q|--quiet 
    -v|--verbose 
    -h|--help                            (does not need an action)
  cleanup and check ignore all options except -q and -v
EOT
  if [ -n "$1" ] ; then
     echo
     ERROR="  ERROR:   "
     echo -e "$*\n" | while read line; do
       echo "${ERROR}${line}" >&2
       ERROR="           "
     done
  fi
  exit 1
}

debug () {
  test "$VERBOSE" = "yes" || return
  echo -e "debug: $*" >&2
}

warn () {
  test "$QUIET" = "yes" && return
  echo -e "$*" >&2
}

log () {
  logger -t "$PROGNAME" "$*"
  debug "$*"
  if [ "$ACTION" = "cleanup" ] ; then
    echo -e "$*"
#    XX="modify_resolfconf:"
#    echo -e "$*" | fmt -60 |
#    while read line; do
#      echo "$XX $line"
#      XX="                  "
#    done
  fi
}

write_resolvconf () {
  cat << EOT > $RESOLVCONF
### BEGIN INFO
#
# Modified_by:  $SERVICE
# Backup:       $BACKUP
# Process:      $PROC
# Process_id:   $PID
# Script:       $SCRIPT
# Saveto:       $SAVELATER
# Info:        
EOT
echo -e "$TEXT" |
  fmt -60 |
  while read line ; do 
    echo "#               $line"; 
  done |
   sed "/^[#[:space:]]*$/d" >> $RESOLVCONF
  cat << EOT >> $RESOLVCONF
#
### END INFO

EOT
echo "$RC_REST" >> $RESOLVCONF
#domain $DOMAIN
#search $SEARCH
#EOT
#for a in $DNS; do
#  echo "nameserver $a" >> $RESOLVCONF
#done
chmod 644 $RESOLVCONF
}

###########################################################
# Parse commandline
###########################################################

# Note that we use `"$@"' to let each command-line parameter expand to a 
# separate word. The quotes around `$@' are essential!
# We need TEMP as the `eval set --' would nuke the return value of getopt.
TEMP=`getopt -o s:p:i:f:t:l:d:n:qvho:a:k --long \
service:,process:,pid:,script:,text:,searchlist:,domain:,nameservers:,\
quiet,verbose,help,save_now:,save_later:,keep \
-n "  $PROGNAME" -- "$@"`
test $? != 0 && usage

# Now set the parsed args
# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"
# echo "$TEMP"

while true ; do
  case "$1" in
    -s|--service) SERVICE="$2"; shift 2;;
#    -e|--extension) EXT="$2"; shift 2;;
    -p|--process) PROC="$2"; shift 2;;
    -i|--pid) PID="$2"; shift 2;;
    -f|--script) SCRIPT="$2"; shift 2;;
    -t|--text) TEXT="$2"; shift 2;;
    -l|--searchlist) SEARCH="$2"; shift 2;;
    -d|--domain) DOMAIN="$2"; shift 2;;
    -n|--nameservers) DNS="$2"; shift 2;;
    -q|--quiet) QUIET=yes; shift;;
    -v|--verbose) VERBOSE=yes; shift;;
    -h|--help) usage;;
    -o|--save_now) SAVENOW="$2"; shift 2;;
    -a|--save_later) SAVELATER="$2"; shift 2;;
    -k|--keep) KEEP=yes; shift;;
    --) shift ; break ;;
    *) echo "Internal error! : $1" ; exit 1 ;;
  esac
done
test $# -ne 1 && usage "Exactly one action may be given.\n"\
                       "Currently given actions: $*"
ACTION=$1

###########################################################
# Check if the arguments to the options are usefull
###########################################################

case $ACTION in
  modify)
    case "$SERVICE" in
      dhclient|dhcpcd|pppd|ipppd|pcmcia|hotplug) ;;
      *) usage "service must be one of dhclient dhcpcd" \
               " pppd ipppd pcmcia hotplug";;
    esac

    if [ "$SERVICE" != "hotplug" ] ; then
      if [ -z "$PROC" ] ; then
        usage "a running process/daemon must be set with --process"
      else
        PROCPID=`pidofproc $PROC 2>/dev/null`
        if [ -z "$PROCPID" ] ; then
          usage "$PROC is not running currently, this may not happen"
        else
          debug "pid of prodess $PROC is $PROCPID"
        fi
      fi
    fi
    
    if [ -z "$PID" ] ; then
      PID="$PROCPID"
      # usage "you must set the pid of $PROC with --pid"
    else
      PIDPROC=`ps h $PID 2>/dev/null |(read a b c d e f; echo $e)`
      if [ -z "$PIDPROC" ] ; then
        warn "there is no process with id $PID"
      else
        debug "process with pid $PID is $PIDPROC"
      fi
    fi
    
    if [ -z "$SCRIPT" ] ; then
      usage "you must set the script that modifies $RESOLVCONF with --script"
    else
      if [ -e "$SCRIPT" ] ; then
        debug "script $SCRIPT found"
      else
        usage "there is no script named $SCRIPT"
      fi
    fi
    
    if [ -z "$TEXT" ] ; then
      usage "You have to provide an descriptive text with --text\n" \
            "With --text=- you can use a here document"
    else
      # If TEXT="-" read it as here document
      if [ "$TEXT" = "-" ] ; then
        TEXT=""
        while read a; do
          test -z "$a" && a="\n\n"
          TEXT="$TEXT $a"
        done
      fi
    fi

    if [ -n "$DOMAIN" -a -n "$SEARCH" ] ; then
      usage "only one of --domain and --searchlist may be used\n" \
            "in resolv.conf search and domain are mutually exclusiv"
    fi
    ;;
  restore) 
    case "$SERVICE" in
      dhclient|dhcpcd|pppd|ipppd|pcmcia|hotplug) ;;
      *) usage "service must be one of dhclient dhcpcd" \
               " pppd ipppd pcmcia hotplug";;
    esac
    ;;
  cleanup|check)
    # ignore all options
    SERVICE="$ACTION"
    KEEP=""
    SAVENOW=""
    ;;
  *) usage "$ACTION is not a valid action" ;;
esac

BACKUP="${RESOLVCONF}.saved.by.$SERVICE"
test -n "$EXT" && BACKUP="${BACKUP}.${EXT}"

###########################################################
# respect MODIFY_RESOLV_CONF_DYNAMICALLY in rc.config
###########################################################

MODIFY=`sed -n "/^[[:space:]]*MODIFY_RESOLV_CONF_DYNAMICALLY=/s/^.*=\|\"//gp" \
                                                                 /etc/rc.config`
if [ -n "$MODIFY" -a "$MODIFY" != "yes" ] ; then
  if [ "$ACTION" = "cleanup" ] ; then
    ls $BACKUP* &>dev/null &&
      log "Not cleaning up $RESOLVCONF backups due to " \
          "MODIFY_RESOLV_CONF_DYNAMICALLY=no"
  else
    log "Service $SERVICE tried to modify $RESOLVCONF, but it"
    log "was not modified due to MODIFY_RESOLV_CONF_DYNAMICALLY=no"
  fi
  exit
fi

###########################################################
# Read current resolv.conf
###########################################################

if [ -e $RESOLVCONF ] ; then
  RC_BLOCK=`sed -n "/### BEGIN INFO/,/### END INFO/s/^[[:space:]#]*//p" \
                                                               $RESOLVCONF`
  if [ -n "$RC_BLOCK" ] ; then
    while read NAME TOKEN; do
      # Note the quotes around RC_BLOCK. Without it we get all in one line.
      eval $NAME=`echo "$RC_BLOCK" | sed -n "/^$TOKEN:[[:space:]]*/s///p"`
      debug "$NAME=${!NAME}"
    done << "      EOL"
      RC_SERVICE   Modified_by
      RC_BACKUP    Backup
      RC_PROC      Process
      RC_PID       Prodess_id
      RC_SCRIPT    Script
      RC_SAVELATER Saveto
      EOL
    # Here we want all in one line so we do not quote RC_BLOCK, but we lose
    # all formatting of the text (to be enhanced). 
    RC_TEXT=`echo $RC_BLOCK | sed -e "s/^.*Info:[[:space:]]*//" \
                                  -e "s/ END INFO.*$//"`
    debug "RC_TEXT=`echo $RC_TEXT | cut -c1-20` ..."
  fi
#  RC_SEARCH=`sed -n "/^search[[:space:]]*/s///p" $RESOLVCONF`
#  RC_DOMAIN=`sed -n "/^domain[[:space:]]*/s///p" $RESOLVCONF`
#  RC_DNS=`sed -n "/^nameserver[[:space:]]*/s///p" $RESOLVCONF`
  RC_REST=`sed "/### BEGIN INFO/,/### END INFO/d" $RESOLVCONF`

fi

###########################################################
# Find the the most rationale of all available backups
###########################################################
# If resolv.conf was modified and there are backups, then:
# - if RC_BACKUP exists delete all other backups
# - if RC_BACKUP does not exist, do some research on these backups and
#   choose the best as RC_BACKUP. Then delete all other backups.
# If resolv.conf was not modified delete all backups.
# If there is no backup leave resolv.conf untouched
# !!! Note that the meaning of RC_BACKUP is changing: !!!
# !!! Up to now it was the filename found in the info block. !!!
# !!! After this section it will contain the name of the choosen backup. !!!

# get all backups except $RC_BACKUP in chronoligical order, the newest first
for a in `ls -t ${RESOLVCONF}.saved.by* 2>/dev/null`; do
  test "$a" = "$RC_BACKUP" && continue
  OTHER_BACKUPS="$OTHER_BACKUPS $a"
done
debug "OTHER_BACKUPS: $OTHER_BACKUPS"
test -e "$RC_BACKUP" || RC_BACKUP=""
debug "RC_BACKUP: $RC_BACKUP"

# If the current resolv.conf does not contain an info block it seems not 
# to be modified or manually written by the admin and we will remove all 
# backups. This should suit all actions:
# -> modify: we make a new backup
# -> restore: there is nothing to restore in this case
# -> cleanup: there is nothing to restore in this case
if [ -z "$RC_BLOCK" ] ; then
  # RC_BACKUP is empty too, so all possible backups are in OTHER_BACKUPS
  TO_DELETE="$OTHER_BACKUPS"
  DELINFO="\"$ACTION\" found unmodified $RESOLVCONF."
elif [ -n "$OTHER_BACKUPS" ] ; then
  # Now there is an info block but RC_BACKUP may be empty.
  if [ -n "$RC_BACKUP" ] ; then
    # It is possible that the backup contains an info block, too. (Even this
    # cannot happen with the current version of this script, there are some
    # problematic enhancements pending that could possible cause such a fault.)
    # So we are going to build a chain of backups and delete the chain elements
    # from OTHER_BACKUPS.
    NEXT_BACKUP="$RC_BACKUP"
    RC_BACKUP=""
    while [ -n "$NEXT_BACKUP" ] ; do
      # BCHAIN contains all elements except the last ...
      BCHAIN="$BCHAIN $RC_BACKUP"
      # ... which is always in RC_BACKUP
      RC_BACKUP="$NEXT_BACKUP"
      NEXT_BACKUP=`sed -n "/### BEGIN INFO/,/### END INFO/s/^[[:space:]#]*Backup:[[:space:]]*//p" $NEXT_BACKUP`
      if [ ! -e "$NEXT_BACKUP" ] ; then
        NEXT_BACKUP="" 
        break
      fi
      OTHER_BACKUPS=`\
      for a in $OTHER_BACKUPS; do
        test "$a" != "$NEXT_BACKUP" && echo "$a"
      done`
    done
    # Now we that we found the end of a backup chain we delete all othe backups
    debug "BCHAIN: $BCHAIN"
    TO_DELETE="$BCHAIN $OTHER_BACKUPS"
    DELINFO="\"$ACTION\" found a backup that was directly or indirectly mentioned in $RESOLVCONF. All other backups will be deleted."
  else
    # Here we have backups but none is written in current resolv.conf.
    # These backups are chronologically ordered.
    # Therefore we look which are named by the current calling service.
    COUNT=0
    TMP="$OTHER_BACKUPS"
    OTHER_BACKUPS=""
    for a in $TMP; do
      if echo $a | grep "$SERVICE" &>/dev/null; then
        SER_BACKUP="$SER_BACKUP $a"
        COUNT=$((COUNT+1))
      else
        OTHER_BACKUPS="$OTHER_BACKUPS $a"
      fi
    done
    debug "OTHER_BACKUPS: $OTHER_BACKUPS"
    debug "SER_BACKUP: $SER_BACKUP"
    debug "COUNT: $COUNT"
    # if the result is exactly one file we take this and do _not_ look if it 
    # contains an info block or not.
    if [ "$COUNT" = 1 ] ; then
      RC_BACKUP="$SER_BACKUP"
      TO_DELETE="$OTHER_BACKUPS"
      DELINFO="\"$ACTION\" found one backup named by the calling service $SERVICE, deleting all other backups."
    else
      # if there are many of them we delete OTHER_BACKUPS and take these as
      # new OTHER_BACKUPS, from which we still have to choose one.
      DI="no backup"; DII="all"
      if [ "$COUNT" -gt 1 ] ; then
        TO_DELETE="$OTHER_BACKUPS"
        OTHER_BACKUPS="$SER_BACKUP"
        DI="many backups"; DII="these"
      fi
      # if there is none we have still to choose from all OTHER_BACKUPS.
      # Now we simply take the newest that does not contain an info block or
      # if all have this block just take the newest.
      RC_BACKUP=`echo "$OTHER_BACKUPS" | (read a b; echo $a)`
      for a in $OTHER_BACKUPS; do
        b=`sed -n "/### BEGIN INFO/,/### END INFO/p" $a`
        test -n "$b" && continue
        RC_BACKUP="$a"
        DIII="that does not contain an info block "
        break
      done
      # Still put all not selected files to TO_DELETE
      for a in $OTHER_BACKUPS; do
        test "$a" = "$RC_BACKUP" && continue
        TO_DELETE="$TO_DELETE $a"
      done
      DELINFO="\"$ACTION\" found ${DI} named by the calling service \"$SERVICE\" and choosed the newest backup ${DIII}from ${DII} backups."
    fi
  fi
fi
if [ -n "$TO_DELETE" ] ; then
  log "$DELINFO"
  log "will remove the following stale backups of $RESOLVCONF:"
  log "$TO_DELETE"
  rm $TO_DELETE 2>/dev/null
fi
# !!! From now on RC_BACKUP contains the name of the single existing backup or
# !!! it is empty if there is no backup.
  
###########################################################
# Finally execute the requested action
###########################################################

# If there is a resolv.conf and --save_now was set then lets do it:
test -n "$SAVENOW" -a -e "$RESOLVCONF" && cp --backup=t $RESOLVCONF $SAVENOW

case $ACTION in
  modify)
    if [ -n "$RC_BACKUP" ] ; then
      if [ "$RC_BACKUP" != "$BACKUP" ] ; then
        mv $RC_BACKUP $BACKUP
      fi
    else
      # maybe there is no resolv.conf
      test -e $RESOLVCONF && cp $RESOLVCONF $BACKUP
    fi
#    test -z "$DNS" && DNS="$RC_DNS"
#    test -z "$SEARCH" && SEARCH="$RC_SEARCH"
#    test -z "$DOMAIN" && DOMAIN="$RC_DOMAIN"
    # Only one of $DOMAIN and $SEARCH does contain something
    if [ -n "$DOMAIN" ] ; then
      RC_REST=`echo "$RC_REST" |
                 sed -e "/^[[:space:]]*\(domain\|search\)[[:space:]]/d"`
      RC_REST=`echo -e "$RC_REST\ndomain $DOMAIN"`
    fi
    if [ -n "$SEARCH" ] ; then
      RC_REST=`echo "$RC_REST" |
                 sed -e "/^[[:space:]]*\(domain\|search\)[[:space:]]/d"`
      RC_REST=`echo -e "$RC_REST\nsearch $SEARCH"`
    fi
    if [ -n "$DNS" ] ; then
      RC_REST=`echo "$RC_REST" | sed "/^[[:space:]]*nameserver[[:space:]]/d"`
      for a in $DNS; do
        RC_REST=`echo -e "$RC_REST\nnameserver $a"`
      done
    fi
    write_resolvconf
    log "Service $SERVICE modified $RESOLVCONF. See info block in this file"
    ;;
  restore|cleanup)
    # If __save_later was set when modifying then we save the temporary
    # resolv.conf
    test -n "$RC_SAVELATER" -a -e "$RESOLVCONF" &&
      cp --backup=t $RESOLVCONF $RC_SAVELATER
    if [ -n "$RC_BACKUP" ] ; then
      if [ "$KEEP" = "yes" ] ; then
        rm $RC_BACKUP
        log "Service $SERVICE forced to keep the modified resolver information"
      else
        mv $RC_BACKUP $RESOLVCONF 
        log "Service $SERVICE restored $RESOLVCONF\n  from backup $RC_BACKUP"
      fi
    fi
    # After restoring resolc.conf it should not contain an INFO block that
    # marks it as modified. If it somehow happens that it has it, we remove it.
    if grep "### BEGIN INFO" $RESOLVCONF 2>/dev/null; then
      cp $RESOLVCONF $TMPFILE
      sed "/### BEGIN INFO/,/### END INFO/d" $TMPFILE >  $RESOLVCONF
      rm $TMPFILE
      chmod 644 $RESOLVCONF
    fi
    ;;
  check)
    if [ -z "$RC_BLOCK" ] ; then
      warn "$RESOLVCONF not modified"
    else
      warn $RC_TEXT
      RETVAL=1
    fi
    ;;
esac

# nscd -i hosts
debug "finished"
exit $RETVAL
