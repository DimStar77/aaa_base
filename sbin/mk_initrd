#! /bin/bash

# Script to create an initial ram disk.
#
# usage:
# mk_initrd [root_dir]
#
#   root_dir: the directory the root partition is mounted to (defaults to "/")
#
#   As an alternative, you can specify the root device via the environment
#   variable rootdev (e.g. "rootdev=/dev/hda mk_initrd").
#
# on errors:
#   exit code > 0
#
# Version 1.09
#
# Author: Steffen Winterfeldt <wfeldt@suse.de>
# (c) 1999 SuSE GmbH
# (c) 1999 Heiko Eißfeldt bugfix, add module parameter passing
#
# ChangeLog:
#
#  6/7/2000:	v1.09
#    - started log
#    - use get_kernel_version instead of file
#    - increased initrd size to 2000k
#

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# general configurable parameters

# the kernel images to use; must be in $boot_dir
kernels="vmlinuz vmlinuz_24 vmlinuz.suse"
arch=`uname -m`
[ "$arch" = ia64 -o "$arch" = ppc ] && kernels="vmlinux vmlinux.suse"
[ "$arch" = alpha ] && kernels="vmlinux.gz vmlinux.suse.gz"

# initial ram disks (corresponding to $kernels); dto. in $boot_dir
initrds="initrd initrd_24 initrd.suse"
[ "$arch" = ia64 -o "$arch" = ppc -o "$arch" = alpha ] && initrds="initrd initrd.suse"

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# adapt these only if needed

# *full* paths
boot_dir=/boot
static_shell=/bin/ash.static
static_insmod=/sbin/insmod.static

# initrd size
image_blocks=2000
image_inodes=100

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# should be nothing to change below...

tmp_mnt=/tmp/mnt$$
tmp_msg=/tmp/msg$$
lx_rc=$tmp_mnt/linuxrc
is_mounted=

clean_up () {
  [ "$is_mounted" ] && umount $tmp_mnt
  rm -f $tmp_initrd $tmp_initrd.gz $tmp_msg
  [ -d $tmp_mnt ] && rmdir $tmp_mnt
}

error () {
  echo "$2"
  clean_up
  exit $1
}

[ "$1" = -r ] && shift

root_dir="$1"
[ "$root_dir" ] || root_dir=/

tmp_initrd=$root_dir/tmp/initrd$$

x1=`mount 2>/dev/null | grep "on $root_dir "`
x2=`echo \`echo "$x1" | wc -l\``
x3=`echo "$x1" | cut -f 1 -d " "`

root_lvm=0
if [ -z "$rootdev" ] 
then
    [ "$x2" = 1 -a -b "$x3" ] && rootdev="$x3"
    major=`ls -l "$rootdev" | sed -e "s/.* \\([0-9]\+\\), *[0-9]\+.*/\\1/"`
    [ "$major" -ne 58 ] || root_lvm=1
fi

if [ $root_lvm -eq 1 ]
then
    echo root device is LVM
    static_shell=/bin/ash
    static_insmod=/sbin/insmod
    image_blocks=6000
    image_inodes=2000
fi

if [ "$root_dir" != / ] ; then
  LD_LIBRARY_PATH=$root_dir/usr/lib
  PATH=$root_dir/usr/bin:$PATH
  [ -x "$root_dir$static_shell" ] && static_shell="$root_dir$static_shell"
  [ -x "$root_dir$static_insmod" ] && static_insmod="$root_dir$static_insmod"
fi

[ "$rootdev" ] || error 1 "usage: mk_initrd [root_dir]"

echo "using \"$rootdev\" as root device (mounted on \"$root_dir\")"

[ -f "$root_dir/etc/rc.config" ] && . $root_dir/etc/rc.config

modules="$INITRD_MODULES"

( cd $root_dir$boot_dir ; rm -f $initrds )
[ "$modules" -o $root_lvm -ne 1 ] || error 0 "no initrd required"

initrd_a=($initrds)

kernel_idx=0
for k in $kernels ; do

  kk="$root_dir$boot_dir/$k"

  if [ -f "$kk" ] ; then

    vv=`/sbin/get_kernel_version $kk`

    ii="$root_dir$boot_dir/${initrd_a[$kernel_idx]}"

    echo
    echo "creating initrd \"$ii\" for kernel \"$kk\" ($vv)"

    [ -d "$root_dir/lib/modules/$vv/misc" ] || error 2 "no version \"$vv\" modules found"

    mkdir $tmp_mnt

    dd if=/dev/zero of=$tmp_initrd bs=1k count=$image_blocks 2>/dev/null
    mke2fs -q -F -b 1024 -m 0 -N $image_inodes $tmp_initrd 2>/dev/null
    tune2fs -i 0 $tmp_initrd >/dev/null 2>&1

    mount -oloop $tmp_initrd $tmp_mnt 2>/dev/null || { 
      if [ -f /lib/loop.o ] ; then
        insmod /lib/loop.o
        mount -oloop $tmp_initrd $tmp_mnt 2>/dev/null || {
          error 3 "failed to mount image"
        }
      else
        error 3 "failed to mount image"
      fi
    }
    is_mounted=1

    rmdir $tmp_mnt/lost+found
    mkdir $tmp_mnt/{bin,dev}
    cp -a $root_dir/dev/{tty1,tty2,zero,null,ram0,ram1,ram2,ram,ramdisk,fb0,console} $tmp_mnt/dev
    cp $static_shell $tmp_mnt/bin/sh 2>/dev/null || error 4 "no static shell"
    cp $static_insmod $tmp_mnt/bin/insmod 2>/dev/null || error 5 "no static insmod"
    if [ $root_lvm -eq 1 ]
    then
	mkdir $tmp_mnt/{lib,etc,proc}
	touch $tmp_mnt/etc/fstab
	cp -a $root_dir/dev/lvm  $tmp_mnt/dev
	cp -a $root_dir/dev/[ehs]d? $root_dir/dev/[ehs]d?[0-9]* $tmp_mnt/dev
	cp -a $root_dir/dev/md? $root_dir/dev/dasd* $tmp_mnt/dev
	cp -a $root_dir/dev/{i2o,ida,cciss} $tmp_mnt/dev
	cp -a $root_dir/lib/{ld-2.2.so,ld-linux.so.2} $tmp_mnt/lib
	cp -a $root_dir/lib/{liblvm.so,libc.so.6} $tmp_mnt/lib
	cp -a $root_dir/lib/libz.so.1* $tmp_mnt/lib
	cp -a $root_dir/sbin/{vgscan,vgchange}  $tmp_mnt/bin
	cp -a $root_dir/bin/{rm,mount,umount}  $tmp_mnt/bin
    fi

    echo '#! /bin/sh' >$lx_rc
    echo >>$lx_rc
    echo "export PATH=/bin" >>$lx_rc
    echo >>$lx_rc

    chmod 755 $lx_rc

    for i in $modules; do
      x=`cd $root_dir ; find lib/modules/$vv/ -name $i.o`
      if [ "$x" ] ; then
        echo "module $i is \"/$x\""
        tar -C $root_dir -cf - $x 2>/dev/null | tar -C $tmp_mnt -xpf - 2>/dev/null
        if [ $? != 0 ] ; then
          echo "failed to add module \"/$x\""
          error 6 "initrd too small"
        fi
        modparms=`grep "^[ 	]*options $i" "$root_dir"/etc/modules.conf`
        modparms="${modparms#* * }"
        echo "echo \"Loading module $i $modparms ...\"" >>$lx_rc
        echo "-> insmod $i $modparms"
        echo "insmod $i $modparms" >>$lx_rc
        echo >>$lx_rc
      else
        error 7 "no such module: $i"
      fi
    done

    if [ $root_lvm -eq 1 ]
    then
	echo "mount -tproc none /proc" >> $lx_rc
	echo "vgscan" >> $lx_rc
	echo "vgchange -a y" >> $lx_rc
	echo "umount /proc" >> $lx_rc
    fi

    umount $tmp_mnt
    is_mounted=

    gzip -9 $tmp_initrd

    cp $tmp_initrd.gz $ii || error 8 "failed to install initrd"

    clean_up

  else

    echo "no kernel image \"$k\""

  fi

  kernel_idx=$((kernel_idx+1))

done

