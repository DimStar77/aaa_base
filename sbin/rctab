#!/bin/bash
#
# /sbin/rctab
#
# Copyright (c) 1997 SuSE GmbH Nuernberg, Germany.   
# please send bugfixes or comments to feedback@suse.de.
#
# Author:  Werner Fink        <werner@suse.de>
#
# Description:
#       rctab   { -e | -l | -r } [-#]
#       -e        edit runlevel(s)
#       -l        list runlevel(s)
#       -r        restore start and stop runlevel links out of fallback
#       -i name   include the service `name' out of fallback into runlevels
#       -#        number of a runlevel [0-6] to edit or list (default: -1 to -5)
#       -S        single user mode to edit or list
#       -B        boot mode to edit or list
#

#
# For debugging
#
: ${debug=0}
#
if test $debug -eq 0 ; then
    test "$UID" = "0" || { echo "$0: Only root should call ${0##/*/}" 1>&2 ; exit 1; }
fi
#
# For our main
#
: ${todo=""}
: ${optkey=""}
: ${EDITOR=vi}
#
tmpdir=/tmp/rctmpdir.$$
tmp="${tmpdir}/rctmp"

trap "rm -rf $tmpdir" 0 1 3 4 7 9 13 15
trap "exit 1" 2
mkdir -p ${tmpdir}
if test $? -gt 0 -o ! -d ${tmpdir} ; then
    echo "Error $0: cannot create $tmpdir" 1>&2
    exit 1
fi
chmod 0700 $tmpdir
#
# make sort secure
#
export TMPDIR=$tmpdir

#
# Some defaults: format of our sorting number in start and stop links
#
: ${rex='[0-9][0-9]'}
: ${frex='%.2d'}
#
# 
#
: ${defaultlevels="1 2 3 4 5"}
: ${initdir="/sbin/init.d/"}
if test $debug -eq 0 ; then
:    ${fallback="/etc/runlevel.fallback"}
else
:    ${fallback="runlevel.fallback"}
fi
#
# Used global variables
#
: ${head=""}
: ${body=""}
: ${levels=""}
: ${succession1=""}
: ${succession2=""}
: ${succession3=""}
: ${succession4=""}
: ${succession5=""}
: ${succession6=""}
: ${succession7=""}
: ${succession8=""}
: ${md=""}
: ${singlescript=""}
: ${do_restore=no}
#

usage () {
    echo " Usage: ${0##/*/}   { -e | -l | -r } [-#]" 1>&2
    echo "        -e        edit runlevel(s)" 1>&2
    echo "        -l        list runlevel(s)" 1>&2
    echo "        -r        restore start and stop runlevel links out of fallback" 1>&2
    echo "        -i name   include the service \`name' out of fallback into runlevels" 1>&2
    echo "        -#        number of a runlevel [0-6] to edit or list (default: -1 to -5)" 1>&2
    echo "        -S        single user mode to edit or list" 1>&2
    echo "        -B        boot mode to edit or list" 1>&2
    exit 1
}

#
# This routine reads in the init directory
# return value is an string containing all usable service scripts
#
function readinitdir () {
    local script;
    local return;

    test -d $initdir && cd $initdir || return;

    for script in * ; do
	case "${script##/*/}" in
	    README|skeleton|rc|rx|\
	    makerunlvl|boot|boot\.local|\
	    powerfail|*\~|*\,v) ;;
	    *)  test -x $script -a ! -d $script && return="$return ${script}" ;;
	esac
    done

    echo $return;
}

#
# This routine reads a given runlevel directory
# return value is an string containing all symbolic links
# with S$rex stripped off and K${rex} ignored.
#
function readrldir () {
    local script;
    local dir=$1;
    local return;

    test -d $dir && cd $dir || return;

    for script in * ; do
	case "${script##/*/}" in
	    K${rex}*) ;;
	    *)  test -x $script -a -L $script && \
		 return="$return ${script#S${rex}}" ;;
	esac
    done

    echo $return;
}

#
# This routine will generate us a header and a body ...
# our matrix to fill in some services scripts
# Format:
#   Runlevel:1 Runlevel:2 Runlevel:3 Runlevel:4 Runlevel:5 ...
#   1:1        2:1        3:1        4:1        5:1
#   1:2        2:2        3:2        4:2        5:2
#   1:3        2:3        3:3        4:3        5:3
#   1:4        2:4        3:4        4:4        5:4
#   1:5        2:5        3:5        4:5        5:5
#   1:6        2:6        3:6        4:6        5:6
#   1:7        2:7        3:7        4:7        5:7
#   1:8        2:8        3:8        4:8        5:8
#   ...
#
function inittable () {
    declare -i num
    declare -i rows
    declare -i col
    local templ
    local l
    local r
    local services="$(readinitdir)"

    rows=$(echo $services|wc -w)

    head="#"
    head="$head\n# Generated by rctab: $(date)"
    head="$head\n#"
    head="$head\n#  Special scripts"
    head="$head\n#"
    for l in $services ; do
	case $l in
	    single) head="$head\n#  single -- only for single user mode" ;;
	    halt)   head="$head\n#  halt   -- only for runlevel 0" ;;
	    reboot) head="$head\n#  reboot -- only for runlevel 6" ;;
	    *) ;;
	esac
    done
    head="$head\n#"
    head="$head\n#  Remaining services"
    head="$head\n#"
    for l in $services ; do
	case $l in
	    single|halt|reboot) ;;
	    *) r="$r $l" ;;
	esac
    done
    r="$(echo $r|fold -s -w 76|sed 's@^@# @g')"
    head="$head\n$r"
    head="$head\n#"
    head="$(echo -e "$head")"

    for l in $levels ; do
	case "$l" in
	    B)      body="$body Bootlevel" ;;
	    [0-6S]) body="$body Runlevel:$l" ;;
	    *)      echo "Error $0: No such boot or run level!" 1>&2
		    exit 1
	    ;;
	esac
    done

    num=1
    while test $num -le $rows ; do
	templ=""
	for l in $levels ; do
	    templ="$templ $l:$num"
	done
	body="$body\n$templ"
	num=$((num + 1))
    done
    body=$(echo -e "$body")
}

#
# This routine will fix our matrix after service scripts filled in
# by `placein' or `readin'
#
function cleartable () {
    echo "$body" | \
    sed "s@[0-6SB]:[0-9][0-9][0-9]@-@g;\
	 s@[0-6SB]:[0-9][0-9]@-@g;\
	 s@[0-6SB]:[0-9]@-@g" | \
    column -t
}

#
# This routine will fill in the named service scripts readed by `readrldir'
# in the matrix given by `inittable'
#
function placein () {
    declare -i num
    local line

    for l in $levels ; do
	case "$l" in
	    [0-6S]) set -- $(readrldir /sbin/init.d/rc${l}.d/) ;;
	    B)      set -- $(readrldir /sbin/init.d/boot.d/)   ;;
	    *)      echo "Error $0: No such boot or run level!" 1>&2
		    exit 1
	    ;;
	esac
	num=1
	while test -n "$1" ; do
	    line="${line}s@$l:$num\(\ \|$\)@$1\1@;"
	    shift
	    num=$((num + 1))
	done
	body="$(echo "$body"|sed "$line")"
	line=""
    done
}

#
# This routine will set $levels if not defined on default
#
function genlevels () {
    test -z "$levels" && levels="$defaultlevels"
    levels="$(echo "$levels"|tr ' ' '\n'|sort)"
}

#
# This routine simple checks the format of an given file
# ... generated by `echo $head' and `cleartable' and
#     modified by root
#
function checkrl () {
    declare -i num
    declare -i col
    declare -i nlev
    declare -i head
    declare -i sum
    local file="$1"
    local line
    local s

    test -z "$file" -o -r $file || { echo "Error $0: No file $file." 1>&2 ; return 1; }

    num=0
    head=0
    while read line ; do
	case "$line" in
	    \#*|"")
		head=$((head + 1))
	    ;;
	    *)
		num=$((num + 1))
		sum=$((num + head))
		nlev=0
		if   test $num -eq 1 ; then
		    col=$(echo "$line"|wc -w)
		    line="$(echo $line|tr ' ' '\n')"
		    test $(echo "$line"|grep -c '[rR]unlevel:0') -eq 1 && nlev=$((nlev + 1))
		    test $(echo "$line"|grep -c '[rR]unlevel:1') -eq 1 && nlev=$((nlev + 1))
		    test $(echo "$line"|grep -c '[rR]unlevel:2') -eq 1 && nlev=$((nlev + 1))
		    test $(echo "$line"|grep -c '[rR]unlevel:3') -eq 1 && nlev=$((nlev + 1))
		    test $(echo "$line"|grep -c '[rR]unlevel:4') -eq 1 && nlev=$((nlev + 1))
		    test $(echo "$line"|grep -c '[rR]unlevel:5') -eq 1 && nlev=$((nlev + 1))
		    test $(echo "$line"|grep -c '[rR]unlevel:6') -eq 1 && nlev=$((nlev + 1))
		    test $(echo "$line"|grep -c '[rR]unlevel:S') -eq 1 && nlev=$((nlev + 1))
		    test $(echo "$line"|grep -c '[bB]ootlevel')  -eq 1 && nlev=$((nlev + 1))
		    #
		    # We do not accept a typo nor more than one column for a level
		    #
		    if test $col -ne $nlev ; then
			echo "Error $0: In $sum line syntax error." 1>&2
			return $sum
		    fi
		else
		    if test $col -ne $(echo "$line"|wc -w) ; then
			echo "Error $0: In line $sum wrong number of entries." 1>&2
			return $sum
		    fi
		    for s in $line ; do
			case "$s" in
			    -) ;;
			    *)
				if   test ! -e ${initdir}$s ; then
				    test $do_restore = yes && continue
				    echo "Error $0: In line $sum entry $s does not exist in ${initdir}." 1>&2
				    return $sum
				fi
			    ;;
			esac
		    done
		fi
	    ;;
	esac
    done < $file

    return 0
}

#
# This routine will fill in the service scripts found in our fallback
# or the tmp file written by `echo $head' and `cleartable'
#
function readin () {
    declare -i num
    declare -i col
    declare -i count
    local file="$1"
    local line
    local temp

    test -z "$file" -o -r $file || { echo "Error $0: No file $file." 1>&2 ; return 1; }

    count=1
    while test -n "$(eval echo \$succession$count)" ; do
	eval succession$count=\"\"
	count=$((count + 1))
    done

    num=0
    while read line ; do
	case "$line" in
	    \#*|"") ;;
	    *)
		num=$((num + 1))
		if   test $num -eq 1 ; then
		    col=$(echo "$line"|wc -w)
		fi
		set -- $line
		count=1
		while test $count -le $col ; do
		    eval temp=\$$count
		    test "$temp" = "-" || eval succession$count=\"\$succession$count \$temp\"
		    count=$((count + 1))
		done
	    ;;
	esac
    done < $file

    count=1
    while test -n "$(eval echo \$succession$count)" ; do
	temp="$(eval echo \$succession$count)"
	set -- $temp
	temp="$(echo $temp|tr ' ' '\n'|sort|uniq -d)"
	if test -n "$temp" ; then
	    echo "Error $0: more then one entry of \`$temp' in $1" 1>&2
	    temp=""
	    return 1
	fi
	temp=""
	count=$((count + 1))
    done

    return 0
}

#
# This routine simply sets the start and stop links
# for the given runlevels
#
function makerl () {
    declare -i num
    declare -i m
    declare -i l
    declare -i d
    declare -i check
    local id
    local runlevel
    local services
    local s
    local link
    local rldir

    num=1
    while test -n "$(eval echo \$succession$num)" ; do 
	runlevel="$(eval echo \$succession$num)"
	num=$((num + 1))
	set -- $runlevel
	case "$1" in
	    [rR]unlevel\:[0-6S])
		id=${1#[rR]unlevel:} ; shift
		rldir="${initdir}rc${id}.d/"
	    ;;
	    [bB]ootlevel)
		id=B ; shift
		rldir="${initdir}boot.d/"
	    ;;
	    *)  echo "Error $0: No such boot or run level!" 1>&2
		exit 1
	    ;;
	esac
	services=""
	for s in $* ; do
	    if test -e ${initdir}${s} ; then
		test ! -x ${initdir}${s} && chmod 0755 ${initdir}${s}
		services="$services $s"
	    fi
	    if test ! -x ${initdir}${s} ; then
		test $do_restore = yes && continue
		echo "Error $0: service ${initdir}${s} is not executable in ${initdir}." 1>&2
		exit 1
	    fi
	done
	set -- $services
	m=$#

	if   test $m -eq 0; then
	    echo  "Warning $0: $m services for runlevel $id is not usefull" 1>&2
	    echo  "Warning $0: skipping any change on runlevel $id" 1>&2
	    continue
	elif test $m -le  9; then
	    d=10; l=10
	elif test $m -le 10; then
	    d=10; l=5
	elif test $m -le 11; then
	    d=9; l=5
	elif test $m -le 13; then
	    d=8; l=2
	elif test $m -le 14; then
	    d=7; l=5
	elif test $m -le 15; then
	    d=7; l=1
	elif test $m -le 17; then
	    d=6; l=2
	elif test $m -le 19; then
	    d=5; l=5
	elif test $m -le 20; then
	    d=5; l=2
	elif test $m -le 24; then
	    d=4; l=4
	elif test $m -le 25; then
	    d=4; l=2
	elif test $m -le 33; then
	    d=3; l=2
	elif test $m -le 50; then
	    d=2; l=1
	elif test $m -le 99; then
	    d=1; l=1
	    echo  "Warning $0: $m services for runlevel $id are more then 50 services" 1>&2
	    echo  "Warning $0: unable to spread service sorting numbers on runlevel $id" 1>&2
	else
	    echo  "Error $0: $m services for runlevel $id are more then 99 services" 1>&2
	    echo  "Error $0: skipping any change on runlevel $id" 1>&2
	    continue
	fi

	test -d $rldir || mkdir $rldir
	for s in $services ; do
	    link="S$(printf "${frex}" $l)${s}"
	    check=$(echo ${rldir}/S${rex}${s}|wc -w)
	    l=$((l + d))
	    if test $debug -eq 0 ; then
		(cd $rldir && test ! -e $link -o $check -gt 1 && { rm -f S${rex}${s}; ln -sf ../${s} $link; })
	    else
		echo $check $link
		(cd $rldir && test ! -e $link -o $check -gt 1 && echo "{ rm -f S${rex}${s}; ln -sf ../${s} $link; }")
	    fi
	done
	test "$id" = "B" && continue
	for s in $services ; do
	    l=$((l - d))
	    link="K$(printf "${frex}" $l)${s}"
	    check=$(echo ${rldir}/K${rex}${s}|wc -w)
	    if test $debug -eq 0 ; then
		(cd $rldir && test ! -e $link -o $check -gt 1 && { rm -f K${rex}${s}; ln -sf ../${s} $link; })
	    else
		echo $check $link
		(cd $rldir && test ! -e $link -o $check -gt 1 && echo "{ rm -f K${rex}${s}; ln -sf ../${s} $link; }")
	    fi
	done
    done
}

#
# This routine ``simply'' inserts a start and stop link
# for the given SuSE service script
#  ...
#
function insertscript () { 
    declare -i num
    declare -i n
    declare -i na
    declare -i nf
    declare -i id
    declare -i found
    declare -i count
    declare -i pos
    local wanted="$1"
    local runlevel
    local startservices
    local stopservices
    local rldir
    local tempa
    local tempf

    test -e ${initdir}${wanted} -a ! -x ${initdir}${wanted} && chmod 0755 ${initdir}${wanted}
    if test ! -e ${initdir}${wanted} ; then
	echo "Error $0: \`$wanted' not found in $initdir" 1>&2
	exit 1
    fi

    num=1
    count=0
    while test -n "$(eval echo \$succession$num)" ; do
	runlevel="$(eval echo \$succession$num)"
	num=$((num + 1))
	#
	found=$(echo "$runlevel"| grep -c -w ${wanted})
	test $found -eq 0 && continue
	count=$((count + found))
	#
	set -- $runlevel
	id=${1#[rR]unlevel:}
	shift
	rldir="${initdir}rc${id}.d/"

	if test ! -d $rldir ; then
	    echo "Error $0: runlevel directory $rldir does not exist" 1>&2
	    exit 1
	fi

        startservices=""
        stopservices=""
	for s in $* ; do
	    if test -e ${initdir}${s} ; then
		test ! -x ${initdir}${s} && chmod 0755 ${initdir}${s}
		#
		set -- ${rldir}S${rex}$s
		test -n "$2" && echo -e "Warning $0: more than one start link\n -- $@" 1>&2
		test -x "$1" -o "$s" = "$wanted" && startservices="$startservices $s"
		#
		set -- ${rldir}K${rex}$s
		test -n "$2" && echo -e "Warning $0: more than one stop link\n -- $@" 1>&2
		test -x "$1" -o "$s" = "$wanted" && stopservices="$stopservices $s"
	    fi
	    if test ! -x ${initdir}${s} ; then
		echo "Error $0: service ${initdir}${s} is not executable in ${initdir}." 1>&2
		exit 1
	    fi
	done

	n=1
	for s in $startservices ; do
	    test "$s" = "$wanted" && pos=n
	    n=$((n + 1))
	done

	set -- $startservices
	if test $pos -eq 1 ; then
	    tempa=$2
	    set -- ${rldir}S${rex}$tempa
	    tempa=${1%$tempa}
	    n=${tempa#${rldir}S}
	    n=$((n / 2))
	else
	    eval tempf=\$$((pos - 1))
	    eval tempa=\$$((pos + 1))
	    set -- ${rldir}S${rex}$tempf
	    tempf=${1%$tempf}
	    nf=${tempf#${rldir}S}
	    #
	    set -- ${rldir}S${rex}$tempa
	    tempa=${1%$tempa}
	    na=${tempa#${rldir}S}
	    n=$((na + nf))
	    n=$((n / 2))
	fi
	test $n -gt 99 && n=99
	test $n -lt  1 && n=1

	link="S$(printf "${frex}" $n)${wanted}"
	if test $debug -eq 0 ; then
	    (cd $rldir; test -e $link || { rm -f S${rex}${wanted}; ln -sf ../${wanted} $link; })
	else
	    echo "(cd $rldir; test -e $link || { rm -f S${rex}${wanted}; ln -sf ../${wanted} $link; })"
	fi

	set -- $stopservices
	if test $pos -eq 1 ; then
	    tempa=$2
	    set -- ${rldir}K${rex}$tempa
	    tempa=${1%$tempa}
	    n=${tempa#${rldir}K}
	    n=$((n + 100))
	    n=$((n / 2))
	else
	    eval tempf=\$$((pos - 1))
	    eval tempa=\$$((pos + 1))
	    set -- ${rldir}K${rex}$tempf
	    tempf=${1%$tempf}
	    nf=${tempf#${rldir}K}
	    #
	    set -- ${rldir}K${rex}$tempa
	    tempa=${1%$tempa}
	    na=${tempa#${rldir}K}
	    n=$((na + nf))
	    n=$((n / 2))
	fi
	test $n -gt 99 && n=99
	test $n -lt  1 && n=1

	link="K$(printf "${frex}" $n)${wanted}"
	if test $debug -eq 0 ; then
	    (cd $rldir; test -e $link || { rm -f K${rex}${wanted}; ln -sf ../${wanted} $link; })
	else
	    echo "(cd $rldir; test -e $link || { rm -f K${rex}${wanted}; ln -sf ../${wanted} $link; })"
	fi
    done

    if test $count -eq 0 ; then
	echo "Warning $0: service ${wanted} not found in ${fallback}." 1>&2
	echo "Warning $0: therefore ${wanted} not included in any runlevel" 1>&2
	echo "Warning $0: use \`$0 -e' for including foreign script" 1>&2
    fi
}

##
## Behind this point you will find what is called `main' in C
##

#
# Check for given arguments and options
#
OPTERR=0
while getopts 'elri:0123456SB' optkey; do
    case "$optkey" in
	e) test -z "$todo" && todo=edit    || usage ;;
	l) test -z "$todo" && todo=list    || usage ;;
	r) test -z "$todo" && todo=restore || usage ;;
	i) test -z "$todo" && todo=insert  || usage
	   singlescript="$OPTARG"
	;;
	[0-6SB]) levels="$levels ${optkey}" ;;
	*) usage
	;;
    esac
done
test -z "$todo" && usage

#
# Truncate the serveral jobs we can do
#
case "$todo" in
    list)
	if test -z "$levels" ; then
	    for d in 0 1 2 3 4 5 6; do
		case "$d" in
		    [0-6S]) test -d ${initdir}rc${d}.d/ && levels="$levels $d" ;;
		    B)      test -d ${initdir}boot.d/   && levels="$levels $d" ;;
		    *)      { echo "Error $0: something is wrong!" 1>&2 ; exit 1; } ;;
		esac
	    done
	fi
	genlevels
	inittable
	placein
	echo "$head"
	cleartable
    ;;
    edit)
	declare -i line
	genlevels
	inittable
	placein
	line=$(echo "$head"|wc -l)
	line=$((line + 1))
	echo "$head" >> $tmp
	cleartable   >> $tmp
	md=$(cat $tmp|md5sum)
	$EDITOR +$line $tmp
	while true ; do
	    checkrl $tmp
	    line=$?
	    test $line -eq 0 && break
	    sleep 1
	    echo "      [ press Return to continue or Ctrl-C to abort ]"
	    read dummy
	    $EDITOR +$line $tmp
	done
	while true ; do
	    readin $tmp
	    test $? -eq 0 && break
	    sleep 1
	    echo "      [ press Return to continue or Ctrl-C to abort ]"
	    read dummy
	    $EDITOR $tmp
	done
	if test "$md" = "$(cat $tmp|md5sum)" ; then
	    echo "Oops $0: No changes given, exit now." 1>&2
	    exit 0
	fi
	rm -f  $tmp
	makerl
    ;;
    restore)
	do_restore=yes
	genlevels
	inittable
	checkrl $fallback
	if test $? -gt 0 ; then
	    echo "Error $0: Broken $fallback! Unable to repair boot system!" 1>&2
	    exit 1
	fi
	readin  $fallback
	if test $? -gt 0 ; then
	    echo "Error $0: Broken $fallback! Unable to repair boot system!" 1>&2
	    exit 1
	fi
	makerl
	do_restore=no
    ;;
    insert)
	do_restore=yes
	genlevels
	inittable
	checkrl $fallback
	if test $? -gt 0 ; then
	    echo "Error $0: Broken $fallback! Unable to change boot system!" 1>&2
	    exit 1
	fi
	readin  $fallback
	if test $? -gt 0 ; then
	    echo "Error $0: Broken $fallback! Unable to repair boot system!" 1>&2
	    exit 1
	fi
	insertscript $singlescript
	do_restore=no
    ;;
    *) usage
    ;;
esac
exit 0
