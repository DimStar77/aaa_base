#! /bin/sh
#
# Copyright (c) 1996 SuSE GmbH Nuernberg, Germany.  All rights reserved.
#
# Author: Ruediger Oertel <ro@suse.de>, 1996-2000
#         Werner Fink <werner@suse.de>, 1996-2000
#         Burchard Steinbild <bs@suse.de>, 1996-2000
#         Florian La Roche <florian@suse.de>, 1996
#
# /etc/init.d/boot
#
# first script to be executed from init on system startup
#

. /etc/rc.status
. /etc/rc.config
echo "Running $0"

rc_reset
echo -n "Mounting /proc device"
mount -n -t proc proc /proc
rc_status -v -r

echo -n "Mounting /dev/pts"
optpts="-o mode=0620,gid=5"
mount -n -t devpts $optpts devpts /dev/pts
rc_status -v1 -r

#
# Start blogd, requires /proc and /dev/pts
#
REDIRECT="`showconsole 2>/dev/null`"
test -x /sbin/blogd && /sbin/blogd $REDIRECT

#
# possibly there are file systems on devices, which need a kernel 
# module to be loaded.  So start kerneld as early as possible.
#
if test "$START_KERNELD" = yes -a \
        -x /sbin/kerneld -a ! -e /proc/sys/kernel/modprobe ; then
    echo -n "Starting kerneld:"
    /sbin/kerneld > /dev/null 2>&1
    rc_status -v -r
fi

#
# check if sysrq should be enabled
#
if test -e /proc/sys/kernel/sysrq ; then
if test "$ENABLE_SYSRQ" = yes ; then
    echo "1" > /proc/sys/kernel/sysrq 
else
    echo "0" > /proc/sys/kernel/sysrq 
fi
fi

#
# check if STOP-A should be enabled
#
if test -e /proc/sys/kernel/stop-a ; then
if test "$ENABLE_STOP_A" = yes ; then
    echo "1" > /proc/sys/kernel/stop-a
else
    echo "0" > /proc/sys/kernel/stop-a
fi
fi

# Disable ECN if required.
if test "$DISABLE_ECN" = "yes" -a -f /proc/sys/net/ipv4/tcp_ecn; then
	echo "0" >/proc/sys/net/ipv4/tcp_ecn
fi

#
# maybe we use "Multiple devices".  So initialize MD.
#
if test -f /etc/raidtab -a -x /sbin/raid0run ; then
    echo "Initializing Multiple Devices..."
    /sbin/raid0run -a
elif test -f /etc/mdtab -a -x /sbin/mdadd ; then
    echo "Initializing Multiple Devices..."
    /sbin/mdadd -ar && MDADD_RETURN=0 || MDADD_RETURN=1
    if test $MDADD_RETURN -ne 0 ; then
        if test  -x /sbin/ckraid ; then
            echo "Initializing Multiple Devices failed.  Trying to recover it..."
	    /sbin/mdstop -a	
            for i in /etc/raid?.conf ; do
                /sbin/ckraid --fix $i
            done
            /sbin/mdadd -ar
	    rc_status -v1 -r
        else
            rc_status -v1 -r
        fi
    fi
fi

#
# s390 is 'like' serial console(better: no console ttys at all)
# and we don't have access to the HW Clock
#
if test "$HOSTTYPE" = "s390" ; then
    SERIAL_CONSOLE=yes
    HWCLOCK_ACCESS=no
fi

#
# If we use a serial console, don't use the fsck progress bar
#
if test -z "$SERIAL_CONSOLE"; then
   FSCK_PROGRESSBAR="-C"
else
   FSCK_PROGRESSBAR=""
fi

#
# Find and activate volume groups (HM 1/1/1999)
#
if test -d /etc/lvmtab.d/ -a -x /sbin/vgscan -a -x /sbin/vgchange ; then
    echo "Run file system check on root for LVM activation"
    while read des fs type rest; do
	case "$des" in ""|\#*) continue ;; esac
	case "$fs" in
	    /) break ;;
	    *)       ;;
	esac
    done < /etc/fstab

    FSCK_RETURN=0
    # on first startup of a system with a lvm root device lvm /dev entries 
    # may not exist at this time, so skip fsck in this case
    # skip fsck also for reiserfs case
    if test "$fs" = / -a -f "$des" -a "$type" != "reiserfs"
    then
	fsck $FSCK_PROGRESSBAR -a -t $type /
	FSCK_RETURN=$?
    fi
    # A return code of 1 indicates that file system errors
    # were corrected, but that the boot may proceed.
    # A return code of 2 or larger indicates failure.
    test $FSCK_RETURN -lt 2
    rc_status -v1 -r
    if test $FSCK_RETURN -gt 1 ; then
	# Stop blogd since we reboot after sulogin
	killproc -QUIT /sbin/blogd
	if test -x /etc/init.d/kbd ; then
	    /etc/init.d/kbd start
	fi
	echo
	echo "fsck for root file system (/) failed."
	echo "Please repair it manually and reboot."
	echo "The root file system is currently mounted read-only."
	echo
	echo "Attention: Only CONTROL-D will reboot the system in this"
	echo "maintanance mode. shutdown or reboot will not work."
	echo
	PS1="(repair filesystem) # "
	export PS1
	/sbin/sulogin /dev/console

	# if the user has mounted something rw, this should be umounted
	echo "Unmounting file systems (ignore error messages)"
	umount -avn

	# on umsdos fs this would lead to an error message. so direct
	# errors to /dev/null
	mount -no remount,ro / 2> /dev/null

	sync
	reboot -f
    else
	echo "Remounting root file system (/) read/write for vgscan..."
	mount -n -o remount,rw /
	echo "Scanning for LVM volume groups..."
	/sbin/vgscan
	mount -n -o remount,ro /
	echo "Activating LVM volume groups..."
	/sbin/vgchange -a y
    fi
fi

#
# fsck may need a huge amount of memory, so make sure, it is there.
#
echo "Activating swap-devices in /etc/fstab..."
swapon -a &> /dev/null
rc_status -v1 -r

case `uname -r` in
    0.*|1.*|2.[01].*|2.2.?|2.2.10)
        echo -n "Running update (bdflush) daemon"
        /sbin/update
        rc_status -v -r
	;;
esac

#
# do fsck and start sulogin, if it fails.
#
FSCK_RETURN=0
if test ! -f /fastboot -a -z "$fastboot" ; then
    FSCK_FORCE=""
    test -f /forcefsck && FSCK_FORCE="-f"
    # on an umsdos root fs this mount will fail, so direct error messages 
    # to /dev/null.
    # this seems to be ugly, but should not really be a problem.
    mount -n -o remount,ro / 2> /dev/null
    if test $? = 0; then
        echo "Checking file systems..."
        fsck $FSCK_PROGRESSBAR -A -a $FSCK_FORCE
        # A return code of 1 indicates that file system errors
        # were corrected, but that the boot may proceed.
        # A return code of 2 or larger indicates failure.
        FSCK_RETURN=$?
	test $FSCK_RETURN -lt 2
	rc_status -v1 -r
        if test $FSCK_RETURN -gt 1; then
	    # Stop blogd since we reboot after sulogin
	    killproc -QUIT /sbin/blogd
	    if test -x /etc/init.d/kbd ; then
		/etc/init.d/kbd start
	    fi
            echo
            echo "fsck failed.  Please repair manually and reboot. The root"
            echo "file system is currently mounted read-only. To remount it"
            echo "read-write do:"
            echo
            echo "   bash# mount -n -o remount,rw /"
            echo
            echo "Attention: Only CONTROL-D will reboot the system in this"
            echo "maintanance mode. shutdown or reboot will not work."
            echo
            PS1="(repair filesystem) # "
            export PS1
            /sbin/sulogin /dev/console

            # if the user has mounted something rw, this should be umounted
            echo "Unmounting file systems (ignore error messages)"
            umount -avn

            # on umsdos fs this would lead to an error message. so direct 
            # errors to /dev/null
            mount -no remount,ro / 2> /dev/null

            sync
            reboot -f
        fi
        sync
        mount -n -o remount,rw /
    else
	mounts=/etc/mtab
	test -r /proc/mounts && mounts=/proc/mounts
	while read des fs type rest; do
	    case "$fs" in
	        /) break ;;
	        *)       ;;
	    esac
	done < $mounts

	if test "$fs" = / -a "$type" != "umsdos" ; then
	    echo
	    echo '*** ERROR!  Cannot fsck because root is not read-only!'
	    echo
	fi
    fi
else
    echo "File systems are NOT being checked."
    mount -n -o remount,rw /
fi

# set and adjust the CMOS clock
if test "$HWCLOCK_ACCESS" != "no" ; then
echo -n Setting up the CMOS clock
CLOCKCMD=hwclock
while read line; do
	case "$line" in
#		*MacRISC*)  CLOCKCMD=clock ;;
		*MTX\ Plus*) CLOCKCMD="hwclock --mtxplus --directisa" ;;
		*PReP\ Dual\ MTX*) CLOCKCMD="hwclock --mtxplus --directisa" ;;
	esac
done < /proc/cpuinfo

test "$GMT" != "YAST_ASK" && $CLOCKCMD --hctosys $GMT
rc_status
test -f /etc/adjtime || echo "0.0 0 0.0" > /etc/adjtime
if test "$GMT" != "YAST_ASK"  -a "$START_XNTPD" != "yes" ; then
    $CLOCKCMD --adjust $GMT
    rc_status
fi
rc_status -v -r
fi

#
# clean up
#
rm -f /etc/mtab* /etc/nologin /nologin /fastboot

#
# initialize database for kerneld.  This should be done earlier, but
# could cause a lot of trouble with damaged file systems.
# restart of kerneld will be done by /etc/init.d/kerneld
# 
MODULES_DIR=/lib/modules/`uname -r` 
if test -x /sbin/depmod -a -d $MODULES_DIR ; then
    for i in $MODULES_DIR/* $MODULES_DIR/*/* /etc/modules.conf ; do
        test -e $i || continue
        if test $i -nt $MODULES_DIR/modules.dep ; then
            rm -f $MODULES_DIR/modules.dep
            break
        fi
    done
    if test ! -e $MODULES_DIR/modules.dep ; then
        echo -n Setting up $MODULES_DIR
        /sbin/depmod -a > /dev/null 2>&1
	rc_status -v -r
    fi
fi

#
# Mount local filesystems in '/etc/fstab' (and create an entry 
# for / and /proc).
#
echo "Mounting local file systems..."
mount -fv -t proc proc /proc
rc_status
mount -fv -t devpts $optpts devpts /dev/pts
rc_status
mount -av -t nonfs,noproc,nodevpts
rc_status -v1 -r

#
# After mounting we may activate swap files in /etc/fstab
# .. this should work know with the new swapon behavio(u)r
#
echo "Activating remaining swap-devices in /etc/fstab..."
swapon -a &> /dev/null
rc_status -v1 -r

#
# reinit quota, if fsck has returned value != 0
#
if test $FSCK_RETURN -gt 0 -a -n "$START_QUOTA" -a "$START_QUOTA"="yes" ; then
    # Check quota and then turn quota on.
    if test -x /sbin/quotacheck ; then
        echo "Checking quotas. This may take some time."
        /sbin/quotacheck -avug
	rc_status -v1 -r
    fi
fi

# Let ld.so rebuild its cache.
# But do some tests before if it is really needed (bs@suse.de 01/2000)
LDCONFIG_NEEDED=false
test -s /etc/ld.so.cache || LDCONFIG_NEEDED=true
test "$run_ldconfig" = true && LDCONFIG_NEEDED=true
test -x /usr/bin/find -a "$LDCONFIG_NEEDED" = false && {
    for DUMMY in `/usr/bin/find /etc/ld.so.cache -mtime +30` ; do
        LDCONFIG_NEEDED=true
    done
}
LIBDIRS="/lib /usr/lib /usr/local/lib"
test -s /etc/ld.so.conf && {
    for DIR in `cat /etc/ld.so.conf` ; do
        case $DIR in
          /*)
            test -d "$DIR" && LIBDIRS="$LIBDIRS $DIR"
          ;;
        esac
    done
}
for DIR in $LIBDIRS ; do
    test $DIR -nt /etc/ld.so.cache && {
        LDCONFIG_NEEDED=true
        break
    }
done

test -x /sbin/ldconfig -a "$LDCONFIG_NEEDED" = true && {
    echo -n "Starting ldconfig (setting up /etc/ld.so.cache)"
    { /sbin/ldconfig -X 2>/dev/null || \
        { echo ; echo -e "ldconfig $rc_failed" ; } ; } &
    rc_status -v -r
}

#
# Let zic set timezone - if present.
#
if test -n "$TIMEZONE" -a "$TIMEZONE" != "YAST_ASK" -a -x /usr/sbin/zic ; then
    echo -n Setting up timezone data
    /usr/sbin/zic -l $TIMEZONE
    rc_status -v -r
fi

#
# initialize loopback device
#
if test "$START_LOOPBACK" = yes; then
    echo -n Setting up loopback device
    ifconfig lo 127.0.0.1 netmask 255.0.0.0 up
    rc_status
    case `uname -r` in
    0.*|1.*|2.[012].*)
	route add -net 127.0.0.0 netmask 255.0.0.0 dev lo
	rc_status
        ;;
    esac
    rc_status -v -r
fi

#
# set hostname and domainname
#
test -n "$FQHOSTNAME" && {
    echo -n Setting up hostname
    hostname ${FQHOSTNAME%%.*}
    rc_status -v -r
}
test -n "$YP_DOMAINNAME" && {
    echo -n Setting up YP domainname
    domainname $YP_DOMAINNAME
    rc_status -v -r
} || domainname ""


#
# clean up
#
rm -f /var/lock/* /var/lock/*/* /tmp/.X*lock \
      /var/run/*  /var/run/*/*  /var/spool/uucp/LCK* 2>/dev/null
rm -rf /tmp/screens 2>/dev/null
rm -f /var/run/utmp
echo -n > /var/run/utmp
chmod 664 /var/run/utmp
chown root.tty /var/run/utmp

#
# there could be a new kernel version.  reinit /etc/psdevtab, to be sure.
#
rm -f /etc/psdevtab
test -x /bin/ps && /bin/ps > /dev/null 2> /dev/null

#
# mount shmfs is necessary (2.4 kernels)
#
unset HAVE_SHM
while read dev type; do
    test "$type" = "shm" && HAVE_SHM=1
done < /proc/filesystems
if test ! -z "$HAVE_SHM"; then
    ECHO_RETURN=$rc_done
    test -d /dev/shm || mkdir /dev/shm
    echo -n "Mount SHM FS on /dev/shm"
    mount -t shm shmfs /dev/shm || ECHO_RETURN=$rc_failed
    echo -e $ECHO_RETURN
fi	    
#unset HAVE_SHM

#
# start bootup client scripts.
#
if test -d /etc/init.d/boot.d/ ; then
    for i in /etc/init.d/boot.d/S*; do
	test -f $i || continue
	if test -x "$i" ; then
	    # Active boot scripts, should have their own messages
	    $i start
	else
	    # Old boot scripts, may not have any message
	    echo Running $i
	    /bin/sh $i b
	    rc_status -v1 -r
	fi
    done
fi

#
# setup PNP if config file is present
#
if test -r /etc/isapnp.conf -a -x /sbin/isapnp -a "$START_ISAPNP" = yes ; then
    echo "Initializing PnP devices"
    /sbin/isapnp /etc/isapnp.conf
    rc_status -v1 -r
fi

#
# start user defined bootup script.
#
if test -f /etc/init.d/boot.local ; then
        echo "Running /etc/init.d/boot.local"
        /bin/sh /etc/init.d/boot.local
	rc_status -v1 -r
fi

# Read all kernel messages generated until now and put them in one file.
test -s /var/log/boot.msg && mv -f /var/log/boot.msg /var/log/boot.omsg
if test -x /sbin/klogd ; then
	echo Creating /var/log/boot.msg
	/sbin/klogd -s -o -n -f /var/log/boot.msg
	/bin/sleep 1
	test -s /var/log/boot.msg
	rc_status -v1 -r
elif test -x /bin/dmesg ; then
	echo Creating /var/log/boot.msg
	/bin/dmesg -s16384 > /var/log/boot.msg
	/bin/sleep 1
	test -s /var/log/boot.msg
	rc_status -v1 -r
fi
if test -x /usr/sbin/klogconsole ; then
   if test -z "$SERIAL_CONSOLE" ; then
	( test -c /dev/tty10 && > /dev/tty10 ) > /dev/null 2>&1 && /usr/sbin/klogconsole -r10 
   else
	/usr/sbin/klogconsole -l 7 -r 0
   fi
fi

#
# Say blogd that I/O is possible now
#
killproc -IO /sbin/blogd

#
# enable DEXE binary format
#
if test -d /proc/sys/fs/binfmt_misc -a -x /usr/bin/dosexec; then
  echo -n "Registering DEXE for binfmt"
  echo :DEXE:M::\\x0eDEXE::/usr/bin/dosexec: > \
    /proc/sys/fs/binfmt_misc/register
  rc_status -v -r
fi

#
# Enable "dynamic IP patch"
#
if test -n "$IP_DYNIP" -a "$IP_DYNIP" != no -a \
    -e /proc/sys/net/ipv4/ip_dynaddr ; then
    echo -n "Enabling dynamic IP patch"
    case "$IP_DYNIP" in
	yes)    echo 7         ; ECHO_RETURN=$rc_done ;;
	[1-9])  echo $IP_DYNIP ; ECHO_RETURN=$rc_done ;;
	*)      ECHO_RETURN=" invalid IP_DYNIP=$IP_DYNIP $rc_skipped" ;;
    esac > /proc/sys/net/ipv4/ip_dynaddr || ECHO_RETURN=$rc_failed
    echo -e "$ECHO_RETURN"
fi

#
# Enable syn flood protection
#
if test -n "$IP_TCP_SYNCOOKIES" -a "$IP_TCP_SYNCOOKIES" != no -a \
    -e /proc/sys/net/ipv4/tcp_syncookies ; then
    echo -n "Enabling syn flood protection"
    case "$IP_TCP_SYNCOOKIES" in
        yes)    echo 1         ; ECHO_RETURN=$rc_done ;;
        *)      ECHO_RETURN=" invalid IP_TCP_SYNCOOKIES=$IP_TCP_SYNCOOKIES $rc_skipped" ;;
    esac > /proc/sys/net/ipv4/tcp_syncookies || ECHO_RETURN=$rc_failed
    echo -e "$ECHO_RETURN"
fi


#
# Enable IP forwarding ?
#
if test -e /proc/sys/net/ipv4/ip_forward -a -n "$IP_FORWARD" ; then
    case $IP_FORWARD in
      yes)
        echo -n "Enabling IP forwarding"
        echo "1" > /proc/sys/net/ipv4/ip_forward
      ;;
      *)
        echo -n "Disabling IP forwarding"
        echo "0" > /proc/sys/net/ipv4/ip_forward
      ;;
    esac
    rc_status -v -r
fi

#
# insert memstat module for xosview
#
if test "$LOAD_MEMSTAT_MODULE" = yes ; then
  if test -f $MODULES_DIR/misc/memstat.o ; then
    echo Loading memstat module
    insmod $MODULES_DIR/misc/memstat.o
    rc_status -v1 -r
  fi
fi

#
# Stop blogd
#
killproc -QUIT /sbin/blogd

#
# look for stuff to do for first bootup.
#
if test -e /var/adm/setup/setup.newinst -o -e /usr/lib/YaST/.configured2 ; then
    if test -w / -a "$NO_AUTO_SETUP" != true ; then
	exec 0<> $REDIRECT 1>&0 2>&0
        if test -e /usr/lib/YaST/.configured2 ; then
            echo
            echo It seems, that last installation setup has not been finished...
            echo To be sure, it will be started again.
            echo
            sleep 2
            rm -f /usr/lib/YaST/.configured2
        fi
        /lib/YaST/bootsetup
        #
        # maybe YaST has started gpm. This can lead into trouble with
        # setserial.  Since it is started again, when entering into
        # runlevel 2, we can kill it here.
        #
	test -x /usr/sbin/gpm && \
            killproc -TERM /usr/sbin/gpm > /dev/null 2> /dev/null
    fi
fi


#
# Let YaST2 finish its installation, if you installed with YaST2
#
if test -f /var/lib/YaST2/runme_at_boot ; then
    exec 0<> $REDIRECT 1>&0 2>&0
    test -x     /lib/YaST2/bin/YaST2.firstboot &&     /lib/YaST2/bin/YaST2.firstboot
    test -x /usr/lib/YaST2/bin/YaST2.firstboot && /usr/lib/YaST2/bin/YaST2.firstboot
fi

rc_reset
exit 0
