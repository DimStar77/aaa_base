#! /bin/bash

# mk_initrd - create the inital ramdisk images
# usage: see below usage() or call with -h
#
# Copyright (C) 2001 SuSE GmbH, Nuernberg, Germany
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
# USA.


# Version 1.21
#
# Author: Steffen Winterfeldt <wfeldt@suse.de>
# (c) 1999 SuSE GmbH
# (c) 1999 Heiko Eiﬂfeldt bugfix, add module parameter passing
# (c) 2000 Karsten Keil   option and kernel 2.4 support
#
# ChangeLog:
#
# 13/9/2001:	v1.21
#  - added oem resize support
#  - added support for splash image sizes
#
# 10/9/2001:	v1.20
#  - new header format for splash picture
#  
# 07/9/2001:    v1.19
#  - add "splashanim" feature.
#
# 14/8/2001:	v1.18
#  - run 'raidautorun' only if raid is used
#  - add xor module if missing
#  - hint to run lilo
#
# 13/8/2001:	v1.17
#  - run 'raidautorun' after loading all modules
#    (note: raidautorun is a ash/sash builtin)
#
# 14/5/2001:	v1.16
#  - automagically add lvm-mod.o
#
# 10/5/2001:	v1.15
#  - copy ld-*so* to initrd, not ld-2.2.so
#  - make it work in chroot environment
#
# 7/5/2001:	v1.14
#  - drop vmlinuz_24 (no longer exists)
#
# 5/3/2001:	v1.13 Stefan Rauch <srauch@suse.de>
#  - automatically adjust initrd size
#
# 13/1/2001:	v1.12
#  - continue with next kernel/initrd on errors
#  - create initrd even if modules are missing
#    (exit code 9 is returned in these cases)
#  - keep old initrd if a new one could not be made
#
# 18/12/2000:   v1.11 Karsten Keil <kkeil@suse.de>
#  - adapt changes from pre 7.1
#  - make it working on new 2.4 module tree
#
# 18/8/2000:    v1.10 Karsten Keil <kkeil@suse.de>
#  - support for 2.4 kernel versions
#  - optional parameter for easy use with other kernel versions
#
#  6/7/2000:	v1.09
#  - started log
#  - use get_kernel_version instead of file
#  - increased initrd size to 2000k
#

#
# Print usage and exit
#
usage() {
	cat<<EOM
      	mk_initrd creates initial ramdisk images for booting linux
                  with enviroments which need loading modules before
                  mounting the root device (e.g SCSI controller)

        mk_initrd [options] [root_dir]

        options:
          -h               This Text.
          -k "kernel list" list of kernel images for which initrd files
                           are created (relativ to boot_dir)
                           defaults to "vmlinuz vmlinuz.suse"
          -i "initrd list" list of file names (relativ to boot_dir) for
                           the initrd; position have match to "kernel list"
                           defaults to "initrd initrd.suse"
          -m "module list" modules to include in initrd, defaults to
                           INITRD_MODULES variable in /etc/rc.config
          -b boot_dir      boot dir, defaults to "/boot"
          -d root_device   root device, defaults to the device from which
                           the root_dir is mounted; overwrites the rootdev
                           enviroment variable if set
	  -s size          Add splash animation and bootscreen to initrd.
	  -o file          Add OEM resize support.
			   
        root_dir:          the directory the root partition is mounted to
                           defaults to "/" 
EOM
	exit
}

#
# These are different functions for binary output of a splash file header.
#

function out_byte()
{
 	let x=$1
	echo -en "`printf \\\\%o $x`"
}
function write_int()
{
	let tmp1=($1 & 255)
	let tmp2=($1>>8)
	let tmp2=($tmp2&255)
	let tmp3=($1>>16)
	let tmp3=($tmp3&255)
	let tmp4=($1>>24)
	let tmp4=($tmp4&255)
	out_byte $tmp1
	out_byte $tmp2
	out_byte $tmp3
	out_byte $tmp4
}
function write_short()
{
	let tmp1=($1>>8)
	let tmp2=($1&0xff)
	out_byte $tmp2
	out_byte $tmp1
}

function write_header()
{
  	# write signature
	echo -n "BOOTSPL1"
	# write text x coordinate
	write_short $1
	# write text y coordinate
	write_short $2
	# write text width
	write_short $3
	# write text height
	write_short $4
	# write file length
	write_int $5
}

# You can specify the root device via the environment variable rootdev (e.g.
# "rootdev=/dev/hda mk_initrd").

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# general configurable parameters

# the kernel images to use; must be in $boot_dir
kernels_default="vmlinuz vmlinuz.suse"
arch=`uname -m`
[ "$arch" = ia64 ] && kernels_default="vmlinuz vmlinuz.suse"
[ "$arch" = ppc ] && kernels_default="vmlinux vmlinux.suse"
[ "$arch" = alpha ] && kernels_default="vmlinux.gz vmlinux.suse.gz"

# initial ram disks (corresponding to $kernels); dto. in $boot_dir
initrds_default="initrd initrd.suse"
[ "$arch" = ia64 -o "$arch" = ppc -o "$arch" = alpha ] && initrds_default="initrd initrd.suse"

kernels=""
initrds=""
modules=""
boot_dir=""
splash=""
oem=""

while getopts :hk:i:m:b:d:o:s: a ; do
	case $a in
		\:|\?)	case $OPTARG in
				k)	echo "-k requires kernel list parameter"
					;;
				i)	echo "-i requires initrd list parameter"
					;;
				m)	echo "-m requires module list parameter"
					;;
				b)	echo "-b requires boot dir parameter"
					;;
				d)	echo "-d requires root device parameter"
					;;
				s)	echo "-s requires image size(s)"
					;;
				o)	echo "-o requires oem grow script"
					;;
				*)  echo "Unknown option: -$OPTARG"
					echo "Try mk_initrd -h"
					;;
			esac
			exit 1
			;;
		k)	kernels=$OPTARG
			;;
		i)	initrds=$OPTARG
			;;
		m)	modules=$OPTARG
			;;
		b)	boot_dir=$OPTARG
			;;
		d)	rootdev=$OPTARG
			;;
		o)	oem=$OPTARG
			;;
		s)	splash=$OPTARG
			;;
		h)	usage
			;;
	esac
done
shift `expr $OPTIND - 1`

if [ -n "$kernels" ] ; then
   if [ -z "$initrds" ] ; then
      echo "you have to specify -k and -i or none"
      exit 1
   fi
fi

if [ -z "$kernels" ] ; then
   if [ -n "$initrds" ] ; then
      echo "you have to specify -k and -i or none"
      exit 1
   fi
fi

# the kernel images to use; must be in $boot_dir
[ -z "$kernels" ] && kernels="$kernels_default"

# initial ram disks (corresponding to $kernels); dto. in $boot_dir
[ -z "$initrds" ] && initrds="$initrds_default"

kc=`echo $kernels |wc -w`
ic=`echo $initrds |wc -w`
if [ $kc != $ic ] ; then
    echo "item count in -k and -i lists have to match"
    exit 1
fi


# *full* paths
[ -z "$boot_dir" ] && boot_dir=/boot

static_shell=/bin/ash.static
static_insmod=/sbin/insmod.static
static_fbmngplay=/bin/fbmngplay

bootsplash_anim=/usr/share/splash/device.mng
bootsplash_picture_dir=/usr/share/splash
# maximum initrd size
image_blocks=10000
image_inodes=2000

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# should be nothing to change below...

tmp_mnt=/tmp/mnt$$
tmp_mnt_small=${tmp_mnt}_small
tmp_msg=/tmp/msg$$
lx_rc=$tmp_mnt/linuxrc
is_mounted=
is_mounted_small=

clean_up () {
  [ "$is_mounted" ] && umount $tmp_mnt
  is_mounted=
  [ "$is_mounted_small" ] && umount $tmp_mnt_small
  is_mounted_small=
  rm -f $tmp_initrd $tmp_initrd.gz $tmp_msg
  rm -f $tmp_initrd_small $tmp_initrd_small.gz
  [ -d $tmp_mnt ] && rmdir $tmp_mnt
  [ -d $tmp_mnt_small ] && rmdir $tmp_mnt_small
}

error () {
  echo "$2"
  clean_up
  exit $1
}

oops () {
  echo "$2"
  clean_up
}

[ -n "$1" ] && root_dir="$1"
[ "$root_dir" ] || root_dir=/

tmp_initrd=$root_dir/tmp/initrd$$
tmp_initrd_small=${tmp_initrd}_small

x1=`mount 2>/dev/null | grep "on $root_dir " | tail -1`
x2=`echo \`echo "$x1" | wc -l\``
x3=`echo "$x1" | cut -f 1 -d " "`

root_lvm=0
if [ -z "$rootdev" ] 
then
    [ "$x2" = 1 -a -b "$x3" ] && rootdev="$x3"
    major=`ls -l "$rootdev" | sed -e "s/.* \\([0-9]\+\\), *[0-9]\+.*/\\1/"`
    [ "$major" -ne 58 ] || root_lvm=1
fi

if [ $root_lvm -eq 1 ]
then
    echo root device is LVM
    static_shell=/bin/ash
    static_insmod=/sbin/insmod
fi

if [ "$root_dir" != / ] ; then
  LD_LIBRARY_PATH=$root_dir/usr/lib
  PATH=$root_dir/usr/bin:$PATH
  [ -x "$root_dir$static_shell" ] && static_shell="$root_dir$static_shell"
  [ -x "$root_dir$static_insmod" ] && static_insmod="$root_dir$static_insmod"
fi

[ "$rootdev" ] || error 1 "usage: mk_initrd [root_dir]"

echo "using \"$rootdev\" as root device (mounted on \"$root_dir\")"

[ -f "$root_dir/etc/rc.config" ] && . $root_dir/etc/rc.config

[ -z "$modules" ] && modules="$INITRD_MODULES"

if [ "$root_lvm" = 1 ] ; then
  # add lvm-mod if missing
  echo " $modules " | grep -q " lvm-mod " || modules="lvm-mod $modules"
fi

[ "$modules" -o "$root_lvm" = 1 -o -n "$oem" -o -n "$splash" ] || {
  ( cd $root_dir$boot_dir ; rm -f $initrds )
  error 0 "no initrd required"
}

do_raid=
do_raid5=
has_xor=
for i in $modules ; do
  case $i in
    raid[01]|linear) do_raid=1 ;;
    raid5) do_raid=1 do_raid5=1 ;;
    xor) has_xor=1 ;;
  esac
done

# raid5 needs xor
[ "$do_raid5" -a ! "$has_xor" ] && modules="xor $modules"

if [ "$root_lvm" = 1 ] ; then
  # add lvm-mod if missing
  echo " $modules " | grep -q " lvm-mod " || modules="lvm-mod $modules"
fi

initrd_a=($initrds)

exit_code=0

kernel_idx=0
for k in $kernels ; do

  kk="$root_dir$boot_dir/$k"

  if [ -f "$kk" ] ; then

    vv=`/sbin/get_kernel_version $kk`

    ii="$root_dir$boot_dir/${initrd_a[$kernel_idx]}"

    echo
    echo "creating initrd \"$ii\" for kernel \"$kk\" ($vv)"

    [ -d "$root_dir/lib/modules/$vv/misc" ] || \
    [ -d "$root_dir/lib/modules/$vv/kernel" ] || {
      oops 2 "no version \"$vv\" modules found"
      continue
    }

    mkdir $tmp_mnt
    dd if=/dev/zero of=$tmp_initrd bs=1k count=$image_blocks 2>/dev/null
    mke2fs -q -F -b 1024 -m 0 -N $image_inodes $tmp_initrd 2>/dev/null
    tune2fs -i 0 $tmp_initrd >/dev/null 2>&1

    mount -oloop $tmp_initrd $tmp_mnt 2>/dev/null || { 
      if [ -f /lib/loop.o ] ; then
        insmod /lib/loop.o
        mount -oloop $tmp_initrd $tmp_mnt 2>/dev/null || {
          error 3 "failed to mount image"
        }
      else
        error 3 "failed to mount image"
      fi
    }
    is_mounted=1

    rmdir $tmp_mnt/lost+found
    mkdir $tmp_mnt/{bin,dev}
    cp -a $root_dir/dev/{tty1,tty2,zero,null,ram0,ram1,ram2,ram,ramdisk,fb0,console,md0} $tmp_mnt/dev
    cp $static_shell $tmp_mnt/bin/sh 2>/dev/null || error 4 "no static shell"
    cp $static_insmod $tmp_mnt/bin/insmod 2>/dev/null || error 5 "no static insmod"
    #if [ -n "$splash" ]
    #then
    #	echo -n "Adding bootsplash animation... "
    #	cp $static_fbmngplay $tmp_mnt/bin/fbmngplay 2>/dev/null || \
	#	error 6 "no splashanim package installed?"
	#cp $bootsplash_anim $tmp_mnt 2>/dev/null || \
	#	error 7 "splash animation not found."
	#echo "done."
    #fi
    
    
    if [ $root_lvm -eq 1 ]
    then
	mkdir $tmp_mnt/{lib,etc,proc}
	touch $tmp_mnt/etc/fstab
	cp -a $root_dir/dev/lvm  $tmp_mnt/dev
	cp -a $root_dir/dev/[ehs]d? $root_dir/dev/[ehs]d?[0-9]* $tmp_mnt/dev
	cp -a $root_dir/dev/dasd* $tmp_mnt/dev
	cp -a $root_dir/dev/{i2o,ida,cciss,rd} $tmp_mnt/dev
	cp -a $root_dir/lib/ld-*so* $tmp_mnt/lib
	cp -a $root_dir/lib/liblvm*.so* $tmp_mnt/lib
	cp -a $root_dir/lib/libc.so.6 $tmp_mnt/lib
	cp -a $root_dir/lib/libz.so.1* $tmp_mnt/lib
	cp -a $root_dir/sbin/{vgscan,vgchange}  $tmp_mnt/bin
	cp -a $root_dir/bin/{rm,mount,umount}  $tmp_mnt/bin
    fi

    if [ -n "$oem" ]
    then
	echo "Adding OEM resize support"
	mkdir -p $tmp_mnt/{lib,etc,proc}
	touch $tmp_mnt/etc/fstab
	cp -a $root_dir/dev/[ehs]d? $root_dir/dev/[ehs]d?[0-9]* $tmp_mnt/dev
	cp -a $root_dir/lib/ld-*so* $tmp_mnt/lib
	cp -a $root_dir/lib/libc.so.6 $tmp_mnt/lib
	cp -a $root_dir/lib/libz.so.1* $tmp_mnt/lib
	cp -a $root_dir/sbin/{sfdisk,resize_reiserfs}  $tmp_mnt/bin
	cp -a $root_dir/bin/{sleep,mount,umount,cp,cat,sed}  $tmp_mnt/bin
	cp -a $root_dir/usr/bin/expr  $tmp_mnt/bin
    fi

    echo '#! /bin/sh' >$lx_rc
    echo >>$lx_rc
    echo "export PATH=/bin" >>$lx_rc
    echo >>$lx_rc

    #if [ -n "$splash" ]
    #then
    #	echo "fbmngplay -b -x 878 -y 35 `basename $bootsplash_anim` &" >> $lx_rc
	#echo "" >>$lx_rc
    #fi
    
    chmod 755 $lx_rc

    for i in $modules; do
      x=`cd $root_dir ; find lib/modules/$vv/ -name $i.o`
      if [ "$x" ] ; then
        echo "module $i is \"/$x\""
        tar -C $root_dir -cf - $x 2>/dev/null | tar -C $tmp_mnt -xpf - 2>/dev/null
        if [ $? != 0 ] ; then
          echo "failed to add module \"/$x\""
          oops 6 "initrd too small"
          continue 2
        fi
        modparms=`grep "^[ 	]*options $i" "$root_dir"/etc/modules.conf`
        modparms="${modparms#* * }"
        echo "echo \"Loading module $i $modparms ...\"" >>$lx_rc
        echo "-> insmod $i $modparms"
        echo "insmod $i $modparms" >>$lx_rc
        echo >>$lx_rc
      else
        echo "no such module: $i"
        exit_code=9
#        oops 7 "no such module: $i"
#        continue 2
      fi
    done
    if [ "$do_raid" ] ; then
      echo "-> raidautorun"
      echo "echo \"raidautorun ...\" " >>$lx_rc
      echo "raidautorun" >>$lx_rc
      echo "echo \"done ...\" " >>$lx_rc
      echo >>$lx_rc
    fi

    if [ $root_lvm -eq 1 ]
    then
	echo "mount -tproc none /proc" >> $lx_rc
	echo "vgscan" >> $lx_rc
	echo "vgchange -a y" >> $lx_rc
	echo "umount /proc" >> $lx_rc
    fi

    [ -n "$oem" ] && cat $oem >> $lx_rc

    # now create a second initrd with minimal size
    
    img_size=`expr \`df -k $tmp_mnt | sed '1d' | awk '{print $3}'\` + 1000`
    mkdir $tmp_mnt_small
    
    dd if=/dev/zero of=$tmp_initrd_small bs=1k count=$img_size 2>/dev/null
    mke2fs -q -F -b 1024 -m 0 -N $image_inodes $tmp_initrd_small 2>/dev/null
    tune2fs -i 0 $tmp_initrd_small >/dev/null 2>&1
    
    mount -oloop $tmp_initrd_small $tmp_mnt_small || { 
      error 3 "failed to mount image"
    }
    is_mounted_small=1
    
    rmdir $tmp_mnt_small/lost+found
    cp -a $tmp_mnt/* $tmp_mnt_small || error 6 "copy big image to small image failed"
    
    umount $tmp_mnt_small
    is_mounted_small=
    
    umount $tmp_mnt
    is_mounted=

    gzip -9 $tmp_initrd_small

    cp -f $tmp_initrd_small.gz $ii || {
      oops 8 "failed to install initrd"
      continue
    }

    if [ -n "$splash" ]
    then
	for size in ${splash//,/ }; do
	    bootsplash_picture="$bootsplash_picture_dir/bootsplash-$size.jpg"
	    cfgname=`echo $bootsplash_picture|sed s/\.jpg/\.cfg/g`
	    echo -n "Concatenating splash picture size $size to initrd... "
	    if [ ! -r $cfgname ]
	    then
		echo "No config file present (expected $cfgname)."
		continue
	    fi
	    if [ ! -r $bootsplash_picture ]
	    then
		echo "picture not present. (expected $bootsplash_picture)."
		continue
	    fi
	    source $cfgname
	    size=`wc -c<$bootsplash_picture`
	    write_header $tx $ty $tw $th $size >> $ii
	    cat $bootsplash_picture >> $ii
	    echo "done."
	done
    fi
    
    clean_up

  else

    echo "no kernel image \"$k\""

  fi

  kernel_idx=$((kernel_idx+1))

done

if [ "$exit_code" = 0 -a -f /etc/lilo.conf ] ; then
  if grep -q initrd /etc/lilo.conf ; then
    echo -e "\n\nIf you're using lilo as bootmanager, you may want to run 'lilo' now.\n"
  fi
fi

exit $exit_code
